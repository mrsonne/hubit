{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"\ufeff hubit - a calculation hub At a glance Hubit is an event-driven orchestration hub for your existing calculation tools. It allows you to execute calculation tools as one Hubit composite model with a loose coupling between the model components, centrally configure the interfaces between calculation tools rather than coding them. This allows true separation of responsibility between different teams, easily run your existing calculation tools asynchronously in multiple processes, query the Hubit model for specific results thus avoiding explicitly coding (fixed) call graphs and running superfluous calculations, make parameter sweeps, feed previously calculated results into new calculations thus augmenting old results, store results incrementally during execution and restart from previously stored results (model caching), reuse results if calculations are executed multiple times with the same input (component caching), visualize your Hubit composite model i.e. visualize your existing tools and the attributes that flow between them. Motivation Many work places have developed a rich ecosystem of stand-alone tools. These tools may be developed/maintained by different teams using different programming languages and using different input/output data models. Nevertheless, the tools often depend on results provided the other tools leading to complicated dependencies and error-prone (manual) workflows involving copy & paste. If this sounds familiar you should try Hubit . By defining input and results data structures that are shared between your tools Hubit allows all your Python-wrappable tools to be seamlessly executed asynchronously as a single model. Asynchronous multi-processor execution often assures a better utilization of the available CPU resources compared to sequential single-processor execution. This is especially true when some time is spent in each component i.e. for CPU bound calculations. In practice this performance improvement often compensates the management overhead introduced by Hubit . Executing a fixed call graph is faster than executing the dynamically created call graph created automatically by Hubit . Nevertheless, a fixed call graph will typically always encompass all relevant calculations and provide all results, which in many cases will represent wasteful compute since only a subset of the results are actually needed. Hubit dynamically creates the smallest possible call graph that can provide the results that satisfy the user's query. Further, Hubit can visualize your existing tools and the data flow between them. Teaser The example below is taken from the in-depth tutorial , in the documentation. To get results from a Hubit model requires you to submit a query , which tells Hubit what attributes from the results data structure you want to have calculated. After Hubit has processed the query, i.e. executed relevant components, the values of the queried attributes are returned in the response . # Load model from file hmodel = HubitModel . from_file ( 'model1.yml' , name = 'car' ) # Load the input with open ( \"input.yml\" , \"r\" ) as stream : input_data = yaml . load ( stream , Loader = yaml . FullLoader ) # Set the input on the model object hmodel . set_input ( input_data ) # Query the model query = [ 'cars[0].price' ] response = hmodel . get ( query ) The response looks like this { 'cars[0].price' : 4280.0 } A query for parts prices for all cars looks like this query = [ 'cars[:].parts[:].price' ] response = hmodel . get ( query ) and the corresponding response is { 'cars[:].parts[:].price' : [ [ 480.0 , 1234.0 , 178.0 , 2343.0 , 45.0 ], [ 312.0 , 1120.0 , 178.0 , 3400.0 ] ] } From the response we can see the prices for the five parts that comprise the first car and the prices for the four parts that comprise the second car. The full example illustrates how a second calculation component can be used to calculate the total price for each car. Hubit can render models and queries. In the example below we have rendered the query cars[0].price i.e. the price of the car at index 0 using query = [ 'cars[0].price' ] hmodel . render ( query ) which yields the graph shown below. The graph illustrates nodes in the input data structure, nodes in the the results data structure, the calculation components involved in creating the response as well as hints at which attributes flow in and out of these components. Installation & requirements Install from pypi pip install hubit Install from GitHub pip install git+git://github.com/mrsonne/hubit.git To render hubit models and queries you need to install Graphviz ( https://graphviz.org/download/ ). On e.g. Ubuntu, Graphviz can be installed using the command sudo apt install graphviz","title":"First steps"},{"location":"index.html#hubit-a-calculation-hub","text":"","title":"hubit - a calculation hub"},{"location":"index.html#at-a-glance","text":"Hubit is an event-driven orchestration hub for your existing calculation tools. It allows you to execute calculation tools as one Hubit composite model with a loose coupling between the model components, centrally configure the interfaces between calculation tools rather than coding them. This allows true separation of responsibility between different teams, easily run your existing calculation tools asynchronously in multiple processes, query the Hubit model for specific results thus avoiding explicitly coding (fixed) call graphs and running superfluous calculations, make parameter sweeps, feed previously calculated results into new calculations thus augmenting old results, store results incrementally during execution and restart from previously stored results (model caching), reuse results if calculations are executed multiple times with the same input (component caching), visualize your Hubit composite model i.e. visualize your existing tools and the attributes that flow between them.","title":"At a glance"},{"location":"index.html#motivation","text":"Many work places have developed a rich ecosystem of stand-alone tools. These tools may be developed/maintained by different teams using different programming languages and using different input/output data models. Nevertheless, the tools often depend on results provided the other tools leading to complicated dependencies and error-prone (manual) workflows involving copy & paste. If this sounds familiar you should try Hubit . By defining input and results data structures that are shared between your tools Hubit allows all your Python-wrappable tools to be seamlessly executed asynchronously as a single model. Asynchronous multi-processor execution often assures a better utilization of the available CPU resources compared to sequential single-processor execution. This is especially true when some time is spent in each component i.e. for CPU bound calculations. In practice this performance improvement often compensates the management overhead introduced by Hubit . Executing a fixed call graph is faster than executing the dynamically created call graph created automatically by Hubit . Nevertheless, a fixed call graph will typically always encompass all relevant calculations and provide all results, which in many cases will represent wasteful compute since only a subset of the results are actually needed. Hubit dynamically creates the smallest possible call graph that can provide the results that satisfy the user's query. Further, Hubit can visualize your existing tools and the data flow between them.","title":"Motivation"},{"location":"index.html#teaser","text":"The example below is taken from the in-depth tutorial , in the documentation. To get results from a Hubit model requires you to submit a query , which tells Hubit what attributes from the results data structure you want to have calculated. After Hubit has processed the query, i.e. executed relevant components, the values of the queried attributes are returned in the response . # Load model from file hmodel = HubitModel . from_file ( 'model1.yml' , name = 'car' ) # Load the input with open ( \"input.yml\" , \"r\" ) as stream : input_data = yaml . load ( stream , Loader = yaml . FullLoader ) # Set the input on the model object hmodel . set_input ( input_data ) # Query the model query = [ 'cars[0].price' ] response = hmodel . get ( query ) The response looks like this { 'cars[0].price' : 4280.0 } A query for parts prices for all cars looks like this query = [ 'cars[:].parts[:].price' ] response = hmodel . get ( query ) and the corresponding response is { 'cars[:].parts[:].price' : [ [ 480.0 , 1234.0 , 178.0 , 2343.0 , 45.0 ], [ 312.0 , 1120.0 , 178.0 , 3400.0 ] ] } From the response we can see the prices for the five parts that comprise the first car and the prices for the four parts that comprise the second car. The full example illustrates how a second calculation component can be used to calculate the total price for each car. Hubit can render models and queries. In the example below we have rendered the query cars[0].price i.e. the price of the car at index 0 using query = [ 'cars[0].price' ] hmodel . render ( query ) which yields the graph shown below. The graph illustrates nodes in the input data structure, nodes in the the results data structure, the calculation components involved in creating the response as well as hints at which attributes flow in and out of these components.","title":"Teaser"},{"location":"index.html#installation-requirements","text":"Install from pypi pip install hubit Install from GitHub pip install git+git://github.com/mrsonne/hubit.git To render hubit models and queries you need to install Graphviz ( https://graphviz.org/download/ ). On e.g. Ubuntu, Graphviz can be installed using the command sudo apt install graphviz","title":"Installation &amp; requirements"},{"location":"changelog.html","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [0.5.0] - 2022-03-17 Added Support for negative indices in query paths. The feature is illustrated in examples/car/run.py . Support for negative indices in model paths. The feature is illustrated in examples/tanks/run_prices.py and discussed in examples/tanks/README.md . examples/wall/run_min_temperature.py and discussed in examples/wall/README.md . Reduced computational overhead Fixed Explicit indexing (e.g. 1@IDX) for non-rectangular data. Occasional code stall when using component caching. Component caching in the case where an \"upstream\" result is queried before a downstream. Consider a car price calculation (downstream) that consumes the prices of all parts (upstream). The query \"cars[:].price\" would produce the car price as expected. The query [\"cars[:].price\", \"cars[:].parts[:].price\"] would produce the car price as expected and spawning the same number of workers as \"cars[:].price\" , thus ignoring the superfluous query path \"cars[:].parts[:].price\" . The query, [\"cars[:].parts[:].price\", \"cars[:].price\"] was, however, broken. Image links and model excerpt example in wall example documentation. [0.4.1] - 2021-11-06 Fixed Fix broken link in README.md [0.4.0] - 2021-11-06 Changed Entrypoint functions now accept only two arguments namely _input_consumed and results_provided . Previously three arguments were expected: _input_consumed , _results_consumed and results_provided . Now _results_consumed is simply included in _input_consumed . The changes renders entrypoint functions agnostic to the origin of their input. The component list in the model configuration file must now sit under a key named\"components\". The format for cache files stored in the folder .hubit_cache has changed. To convert old cache files see the example code below. Alternatively, clear the Hubit cache using the function hubit.clear_hubit_cache() . Hyphen is no longer an allowed character for index identifiers. For example this model path is no longer valid segments[IDX_SEG].layers[IDX-LAY] . The example code below converts the cache file old.yml to new.yml . The file name old.yml will, more realistically, be named something like a70300027991e56db5e3b91acf8b68a5.yml . import re import yaml with open ( \"old.yml\" , \"r\" ) as stream : old_cache_data = yaml . load ( stream , Loader = yaml . FullLoader ) # Replace \".DIGIT\" with \"[DIGIT]\" in all keys (paths) with open ( \"new.yml\" , \"w\" ) as handle : yaml . dump ( { re . sub ( r \"\\.(\\d+)\" , r \"[\\1]\" , path ): val for path , val in old_cache_data . items () }, handle , ) All files in the Hubit cache folder .hubit_cache should be converted if you want them to be compatible with Hubit 0.4.0+. Added Support for subscriptions to other domains (compartments/cells/elements). Now you can easily configure one domain to use a result from other domains as input as well as set up boundary conditions. This new feature is illustrated in the example with connected tanks in examples/tanks/README.md . To enable connected domains Hubit now allows Components to share the same entrypoint function. Components to be scoped using the new field component.index_scope . Components to consume specific elements in lists. Index offsets which enables one domain to refer to e.g. the previous domain. Improved performance for cases where only some branches in the input data tree are consumed, and where branches are not consumed all the way to the leaves. Improved model validation. Improved documentation for model configuration file format. Fixed Fix broken example ( examples/wall/run_precompute.py ) The elements of lists that are leaves in the input data tree can now be referenced and queried. Lists of length 1 in the input were erroneously interpreted as a simple value. [0.3.0] - 2021-05-07 Changed The model configuration format is defined and documented in the HubitModelConfig class. Introducing HubitModelConfig four configuration attributes have been renamed. Therefore, model configuration files used in Hubit 0.3- must be migrated to Hubit 0.3 format. Below is a description of the necessary migrations The top-level object provides is now named provides_results . The sub-objects consumes.input is now a top-level object named consumes_input . The sub-objects consumes.results is now a top-level object named consumes_results . The value of module_path should now be specified in the path and is interpreted as a path present in sys.path that can be imported as a dotted path. The most common use case is a package in site-packages . If path is a dotted path is_python_path should be set to True . Added Improved model configuration validation Documentation [0.2.0] - 2021-03-26 Added Model-level results caching. Component-level results caching. Introduced logging object accessed using my_hubit_model.log() . [0.1.0] - 2021-02-28 Added First release","title":"Change log"},{"location":"changelog.html#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog.html#050-2022-03-17","text":"","title":"[0.5.0] - 2022-03-17"},{"location":"changelog.html#added","text":"Support for negative indices in query paths. The feature is illustrated in examples/car/run.py . Support for negative indices in model paths. The feature is illustrated in examples/tanks/run_prices.py and discussed in examples/tanks/README.md . examples/wall/run_min_temperature.py and discussed in examples/wall/README.md . Reduced computational overhead","title":"Added"},{"location":"changelog.html#fixed","text":"Explicit indexing (e.g. 1@IDX) for non-rectangular data. Occasional code stall when using component caching. Component caching in the case where an \"upstream\" result is queried before a downstream. Consider a car price calculation (downstream) that consumes the prices of all parts (upstream). The query \"cars[:].price\" would produce the car price as expected. The query [\"cars[:].price\", \"cars[:].parts[:].price\"] would produce the car price as expected and spawning the same number of workers as \"cars[:].price\" , thus ignoring the superfluous query path \"cars[:].parts[:].price\" . The query, [\"cars[:].parts[:].price\", \"cars[:].price\"] was, however, broken. Image links and model excerpt example in wall example documentation.","title":"Fixed"},{"location":"changelog.html#041-2021-11-06","text":"","title":"[0.4.1] - 2021-11-06"},{"location":"changelog.html#fixed_1","text":"Fix broken link in README.md","title":"Fixed"},{"location":"changelog.html#040-2021-11-06","text":"","title":"[0.4.0] - 2021-11-06"},{"location":"changelog.html#changed","text":"Entrypoint functions now accept only two arguments namely _input_consumed and results_provided . Previously three arguments were expected: _input_consumed , _results_consumed and results_provided . Now _results_consumed is simply included in _input_consumed . The changes renders entrypoint functions agnostic to the origin of their input. The component list in the model configuration file must now sit under a key named\"components\". The format for cache files stored in the folder .hubit_cache has changed. To convert old cache files see the example code below. Alternatively, clear the Hubit cache using the function hubit.clear_hubit_cache() . Hyphen is no longer an allowed character for index identifiers. For example this model path is no longer valid segments[IDX_SEG].layers[IDX-LAY] . The example code below converts the cache file old.yml to new.yml . The file name old.yml will, more realistically, be named something like a70300027991e56db5e3b91acf8b68a5.yml . import re import yaml with open ( \"old.yml\" , \"r\" ) as stream : old_cache_data = yaml . load ( stream , Loader = yaml . FullLoader ) # Replace \".DIGIT\" with \"[DIGIT]\" in all keys (paths) with open ( \"new.yml\" , \"w\" ) as handle : yaml . dump ( { re . sub ( r \"\\.(\\d+)\" , r \"[\\1]\" , path ): val for path , val in old_cache_data . items () }, handle , ) All files in the Hubit cache folder .hubit_cache should be converted if you want them to be compatible with Hubit 0.4.0+.","title":"Changed"},{"location":"changelog.html#added_1","text":"Support for subscriptions to other domains (compartments/cells/elements). Now you can easily configure one domain to use a result from other domains as input as well as set up boundary conditions. This new feature is illustrated in the example with connected tanks in examples/tanks/README.md . To enable connected domains Hubit now allows Components to share the same entrypoint function. Components to be scoped using the new field component.index_scope . Components to consume specific elements in lists. Index offsets which enables one domain to refer to e.g. the previous domain. Improved performance for cases where only some branches in the input data tree are consumed, and where branches are not consumed all the way to the leaves. Improved model validation. Improved documentation for model configuration file format.","title":"Added"},{"location":"changelog.html#fixed_2","text":"Fix broken example ( examples/wall/run_precompute.py ) The elements of lists that are leaves in the input data tree can now be referenced and queried. Lists of length 1 in the input were erroneously interpreted as a simple value.","title":"Fixed"},{"location":"changelog.html#030-2021-05-07","text":"","title":"[0.3.0] - 2021-05-07"},{"location":"changelog.html#changed_1","text":"The model configuration format is defined and documented in the HubitModelConfig class. Introducing HubitModelConfig four configuration attributes have been renamed. Therefore, model configuration files used in Hubit 0.3- must be migrated to Hubit 0.3 format. Below is a description of the necessary migrations The top-level object provides is now named provides_results . The sub-objects consumes.input is now a top-level object named consumes_input . The sub-objects consumes.results is now a top-level object named consumes_results . The value of module_path should now be specified in the path and is interpreted as a path present in sys.path that can be imported as a dotted path. The most common use case is a package in site-packages . If path is a dotted path is_python_path should be set to True .","title":"Changed"},{"location":"changelog.html#added_2","text":"Improved model configuration validation Documentation","title":"Added"},{"location":"changelog.html#020-2021-03-26","text":"","title":"[0.2.0] - 2021-03-26"},{"location":"changelog.html#added_3","text":"Model-level results caching. Component-level results caching. Introduced logging object accessed using my_hubit_model.log() .","title":"Added"},{"location":"changelog.html#010-2021-02-28","text":"","title":"[0.1.0] - 2021-02-28"},{"location":"changelog.html#added_4","text":"First release","title":"Added"},{"location":"config-reference.html","text":"Hubit configuration, data and queries Objects defined here will automatically be created by Hubit . Therefore, the class definitions below simply document e.g. the attributes required in a model config file or the required structure of a query path. HubitQueryPath ( _HubitPath ) Reference a field in the results data. The syntax follows general Python syntax for nested objects. Only square brackets are allowed. The content of the brackets is called an index specifier and must comply with QueryIndexSpecifier . To query, for example, the attribute weight in the 4 th element of the list wheels , which is stored on the object car use the path car.wheels[3].weight . The query path car.wheels[:].weight represents a list with elements being the weight for all wheels of the car. If there are multiple cars stored in a list of cars, the query path cars[:].wheels[3].weight represents a list where the elements would be the weights for the 4 th wheel for all cars. The query path cars[:].wheels[:].weight represents a nested list where each outer list item represents a car and the corresponding inner list elements represent the weights for all wheels for that car. HubitModelConfig dataclass Defines the hubit model configuration. Parameters: Name Type Description Default components List[HubitModelComponent] HubitModelComponent sequence. required HubitModelComponent dataclass Represents one isolated task carried out by the function func_name located at path . The function requires input from the paths defined in consumes_input and consumes_results . The componet delivers results to the paths in provides_results . Parameters: Name Type Description Default path str Path to the module responsible for the task. if is_dotted_path is false the path attribute is relative to the base_path which is the parent path for the model file. required func_name str The function name (entrypoint) that wraps the task. 'main' provides_results List[HubitBinding] HubitBinding sequence specifying the results provided by the component. The names in the bindings must be unique within provides_results for the component. required consumes_input List[HubitBinding] HubitBinding sequence specifying the input consumed by the component. The names in the bindings must be unique within consumes_input and consumes_results for the component. <factory> consumes_results List[HubitBinding] HubitBinding sequence specifying the input consumed by the component. The names in the bindings must be unique within consumes_input and consumes_results for the component. <factory> index_scope dict A map from the index identifiers to an index. Used to limit the scope of the component. If, for example, the scope is {IDX_TANK: 0} the component is only used when the value of the index identifier IDX_TANK is 0. The scope can only have one element. Values must comply with PathIndexRange . <factory> is_dotted_path bool Set to True if the specified path is a dotted path (typically for a package module in site-packages). False HubitBinding dataclass Binds an internal component attribute with name to a field at path in the shared data model Parameters: Name Type Description Default path HubitModelPath HubitModelPath pointing to the relevant field in the shared data. required name str Attribute name as it will be exposed in the component. required HubitModelPath ( _HubitPath ) References a field in the input or results data. Compared to a HubitQueryPath , a HubitModelPath instance has different rules for index specifiers (see ModelIndexSpecifier ). To illustrate the use of the index identifiers for index mapping in a model path consider a Hubit model component that consumes the path cars[IDX_CAR].parts[:@IDX_PART].name (as discussed here )). The component could use the parts names for a database lookup to get the prices for each component. If we want Hubit to store these prices in the results, one option would be to store them in a data structure similar to the input. To achieve this behavior the component should provide a path that looks something like cars[IDX_CAR].parts[:@IDX_PART].price . Alternatively, the provided path could be cars[IDX_CAR].parts_price[:@IDX_PART] . In both cases, the index identifiers defined in the input path ( cars[IDX_CAR].parts[:@IDX_PART].name ) allows Hubit to store the parts prices for a car at the same car index and part index as where the input was taken from. Note that the component itself is unaware of which car (car index) the input represents. Hubit infers indices and list lengths based on the input data and the index specifiers defined for binding paths in the consumes_input section. Therefore, index identifiers used in binding paths in the consumes_results and provides_results sections should always be exist in binding paths in consumes_input . Further, to provide a meaningful index mapping, the index specifier used in a binding path in the provides_results section should be identical to the corresponding index specifier in the consumes_input . The first binding in the example below has a more specific index specifier (for the identifier IDX_PART ) and is therefore invalid. The second binding is valid. provides_results : # INVALID - name : part_name path : cars[IDX_CAR].parts[IDX_PART].name # more specific for the part index # VALID: Assign a 'price' attribute each part object in the car object. - name : parts_price path : cars[IDX_CAR].parts[:@IDX_PART].price # index specifier for parts is equal to consumes.input.path consumes_input : - name : part_name path : cars[IDX_CAR].parts[:@IDX_PART].name In the invalid binding above, the component consumes all indices of the parts list and therefore storing the price data at a specific part index is not possible. The bindings below are valid since IDX_PART is omitted for the bindings in the provides_results section provides_results : # Assign a 'part_names' attribute to the car object. # Could be a a list of all part names for that car - name : part_names path : cars[IDX_CAR].part_names # index specifier for parts omitted # Assign a 'concatenates_part_names' attribute to the car object. # Could be a string with all part names concatenated - name : concatenates_part_names path : cars[IDX_CAR].concatenates_part_names # index specifier for parts omitted consumes_input : - name : part_name path : cars[IDX_CAR].parts[:@IDX_PART].name Index contexts In addition to defining the index identifiers the input sections also defines index contexts. The index context is the order and hierarchy of the index identifiers. For example an input binding cars[IDX_CAR].parts[IDX_PART].price would define both the index identifiers IDX_CAR and IDX_PART as well as define the index context IDX_CAR -> IDX_PART . This index context shows that a part index exists only in the context of a car index. Index identifiers should be used in a unique context i.e. if one input binding defines cars[IDX_CAR].parts[IDX_PART].price then defining or using parts[IDX_PART].cars[IDX_CAR].price is not allowed. Query dataclass A Hubit query. Parameters: Name Type Description Default paths List[HubitQueryPath] HubitQueryPath sequence. required FlatData ( dict , Generic ) A key-value pair data representation. Keys represent a path in the internal dotted-style. In a dotted-style Hubit path index braces [IDX] are represented by dots .IDX. as_dict ( self ) Converts the object to a regular dictionary with string keys inflate ( self ) Inflate flat data to nested dict. Lists are represented as dicts to handle queries that do not include all list elements. For example, if the query [\"cars[57].price\"] gives the flat data object {\"cars.57.price\": 4280.0} , the inflated version is {'cars': {57: {'price': 4280.0}} . The access syntax for the dictionary representation of lists is identical to the access syntax had it been a list. Using dictionaries we can, however, represent element 57 without adding empty elements for the remaining list elements. QueryIndexSpecifier ( _IndexSpecifier ) Index specifiers for HubitQueryPath . Currently, index specifiers should be either a positive integer or the character : . General slicing is not supported. ModelIndexSpecifier ( _IndexSpecifier ) Index specifiers for HubitModelPath . A model path index specifier is composed of three parts namely the range , the identifier and the offset , in that order. The structure of an model index specifier is \" range @ identifier offset \" with spaces added to increase clarity. The identifier is used internally map an index in input lists to the equivalent index in the results. Can be any string of characters in a-z, A-Z, digits as well as _ (underscore). An example could be MYIDX , which would refer to one index in a list. The range must conform with PathIndexRange and may be used to control the scope of an identifier . An example could be 0 or : . The offset is a signed integer that may be used to offset the affected index. An example could be -1 . Using the examples above the model index specifier would be :@MYIDX-1 . The range and last are optional. A non-empty range requires an empty (i.e. zero) offset and vice versa. To put index specifiers into some context consider a Hubit component that provides cars[IDX_CAR].parts[:@IDX_PART].name . This path tells Hubit that the names of all parts of a specific car can be provided. Let us break down the path and take a closer look at the index specifers in square brackets. The index specifier :@IDX_PART refers to all elements of the parts list (using the range : ) and defines the identifier ( IDX_PART ) to represent elements of the parts list. So in this case, the index specifier contains both a range and an identifier, but no offset. The left-most index specifier IDX_CAR only contains an identifier that represents elements of the cars list. Since no range is specified the identifier refers to a specific car determined by the query (e.g. cars[6].parts[:].name ). cars[IDX_CAR].parts[:@IDX_PART].name therefore references the names of all parts of a specific car which depend on the query specified by the user. A component that consumes this path would have access to these names in a list. The index specifier 0@IDX_PART would always reference element 0 of the parts list irrespective of the query. PathIndexRange ( str ) In HubitModelPath and HubitQueryPath the supported ranges comprise Positive integers e.g. 0 , 17 . Negative integers e.g. -1 , -2 . The all-index character : . Further, in the index_scope attribute of HubitModelComponent the following ranges are also allowed d: where d is a positive integer e.g. 3: . :d where d is a positive integer e.g. :3 . d1:d2 where d1 and d2 are positive integers and d1 < d2 e.g. 2:5","title":"Config & data"},{"location":"config-reference.html#hubit-configuration-data-and-queries","text":"Objects defined here will automatically be created by Hubit . Therefore, the class definitions below simply document e.g. the attributes required in a model config file or the required structure of a query path.","title":"Hubit configuration, data and queries"},{"location":"config-reference.html#hubit.config.HubitQueryPath","text":"Reference a field in the results data. The syntax follows general Python syntax for nested objects. Only square brackets are allowed. The content of the brackets is called an index specifier and must comply with QueryIndexSpecifier . To query, for example, the attribute weight in the 4 th element of the list wheels , which is stored on the object car use the path car.wheels[3].weight . The query path car.wheels[:].weight represents a list with elements being the weight for all wheels of the car. If there are multiple cars stored in a list of cars, the query path cars[:].wheels[3].weight represents a list where the elements would be the weights for the 4 th wheel for all cars. The query path cars[:].wheels[:].weight represents a nested list where each outer list item represents a car and the corresponding inner list elements represent the weights for all wheels for that car.","title":"HubitQueryPath"},{"location":"config-reference.html#hubit.config.HubitModelConfig","text":"Defines the hubit model configuration. Parameters: Name Type Description Default components List[HubitModelComponent] HubitModelComponent sequence. required","title":"HubitModelConfig"},{"location":"config-reference.html#hubit.config.HubitModelComponent","text":"Represents one isolated task carried out by the function func_name located at path . The function requires input from the paths defined in consumes_input and consumes_results . The componet delivers results to the paths in provides_results . Parameters: Name Type Description Default path str Path to the module responsible for the task. if is_dotted_path is false the path attribute is relative to the base_path which is the parent path for the model file. required func_name str The function name (entrypoint) that wraps the task. 'main' provides_results List[HubitBinding] HubitBinding sequence specifying the results provided by the component. The names in the bindings must be unique within provides_results for the component. required consumes_input List[HubitBinding] HubitBinding sequence specifying the input consumed by the component. The names in the bindings must be unique within consumes_input and consumes_results for the component. <factory> consumes_results List[HubitBinding] HubitBinding sequence specifying the input consumed by the component. The names in the bindings must be unique within consumes_input and consumes_results for the component. <factory> index_scope dict A map from the index identifiers to an index. Used to limit the scope of the component. If, for example, the scope is {IDX_TANK: 0} the component is only used when the value of the index identifier IDX_TANK is 0. The scope can only have one element. Values must comply with PathIndexRange . <factory> is_dotted_path bool Set to True if the specified path is a dotted path (typically for a package module in site-packages). False","title":"HubitModelComponent"},{"location":"config-reference.html#hubit.config.HubitBinding","text":"Binds an internal component attribute with name to a field at path in the shared data model Parameters: Name Type Description Default path HubitModelPath HubitModelPath pointing to the relevant field in the shared data. required name str Attribute name as it will be exposed in the component. required","title":"HubitBinding"},{"location":"config-reference.html#hubit.config.HubitModelPath","text":"References a field in the input or results data. Compared to a HubitQueryPath , a HubitModelPath instance has different rules for index specifiers (see ModelIndexSpecifier ). To illustrate the use of the index identifiers for index mapping in a model path consider a Hubit model component that consumes the path cars[IDX_CAR].parts[:@IDX_PART].name (as discussed here )). The component could use the parts names for a database lookup to get the prices for each component. If we want Hubit to store these prices in the results, one option would be to store them in a data structure similar to the input. To achieve this behavior the component should provide a path that looks something like cars[IDX_CAR].parts[:@IDX_PART].price . Alternatively, the provided path could be cars[IDX_CAR].parts_price[:@IDX_PART] . In both cases, the index identifiers defined in the input path ( cars[IDX_CAR].parts[:@IDX_PART].name ) allows Hubit to store the parts prices for a car at the same car index and part index as where the input was taken from. Note that the component itself is unaware of which car (car index) the input represents. Hubit infers indices and list lengths based on the input data and the index specifiers defined for binding paths in the consumes_input section. Therefore, index identifiers used in binding paths in the consumes_results and provides_results sections should always be exist in binding paths in consumes_input . Further, to provide a meaningful index mapping, the index specifier used in a binding path in the provides_results section should be identical to the corresponding index specifier in the consumes_input . The first binding in the example below has a more specific index specifier (for the identifier IDX_PART ) and is therefore invalid. The second binding is valid. provides_results : # INVALID - name : part_name path : cars[IDX_CAR].parts[IDX_PART].name # more specific for the part index # VALID: Assign a 'price' attribute each part object in the car object. - name : parts_price path : cars[IDX_CAR].parts[:@IDX_PART].price # index specifier for parts is equal to consumes.input.path consumes_input : - name : part_name path : cars[IDX_CAR].parts[:@IDX_PART].name In the invalid binding above, the component consumes all indices of the parts list and therefore storing the price data at a specific part index is not possible. The bindings below are valid since IDX_PART is omitted for the bindings in the provides_results section provides_results : # Assign a 'part_names' attribute to the car object. # Could be a a list of all part names for that car - name : part_names path : cars[IDX_CAR].part_names # index specifier for parts omitted # Assign a 'concatenates_part_names' attribute to the car object. # Could be a string with all part names concatenated - name : concatenates_part_names path : cars[IDX_CAR].concatenates_part_names # index specifier for parts omitted consumes_input : - name : part_name path : cars[IDX_CAR].parts[:@IDX_PART].name","title":"HubitModelPath"},{"location":"config-reference.html#hubit.config.HubitModelPath--index-contexts","text":"In addition to defining the index identifiers the input sections also defines index contexts. The index context is the order and hierarchy of the index identifiers. For example an input binding cars[IDX_CAR].parts[IDX_PART].price would define both the index identifiers IDX_CAR and IDX_PART as well as define the index context IDX_CAR -> IDX_PART . This index context shows that a part index exists only in the context of a car index. Index identifiers should be used in a unique context i.e. if one input binding defines cars[IDX_CAR].parts[IDX_PART].price then defining or using parts[IDX_PART].cars[IDX_CAR].price is not allowed.","title":"Index contexts"},{"location":"config-reference.html#hubit.config.Query","text":"A Hubit query. Parameters: Name Type Description Default paths List[HubitQueryPath] HubitQueryPath sequence. required","title":"Query"},{"location":"config-reference.html#hubit.config.FlatData","text":"A key-value pair data representation. Keys represent a path in the internal dotted-style. In a dotted-style Hubit path index braces [IDX] are represented by dots .IDX.","title":"FlatData"},{"location":"config-reference.html#hubit.config.FlatData.as_dict","text":"Converts the object to a regular dictionary with string keys","title":"as_dict()"},{"location":"config-reference.html#hubit.config.FlatData.inflate","text":"Inflate flat data to nested dict. Lists are represented as dicts to handle queries that do not include all list elements. For example, if the query [\"cars[57].price\"] gives the flat data object {\"cars.57.price\": 4280.0} , the inflated version is {'cars': {57: {'price': 4280.0}} . The access syntax for the dictionary representation of lists is identical to the access syntax had it been a list. Using dictionaries we can, however, represent element 57 without adding empty elements for the remaining list elements.","title":"inflate()"},{"location":"config-reference.html#hubit.config.QueryIndexSpecifier","text":"Index specifiers for HubitQueryPath . Currently, index specifiers should be either a positive integer or the character : . General slicing is not supported.","title":"QueryIndexSpecifier"},{"location":"config-reference.html#hubit.config.ModelIndexSpecifier","text":"Index specifiers for HubitModelPath . A model path index specifier is composed of three parts namely the range , the identifier and the offset , in that order. The structure of an model index specifier is \" range @ identifier offset \" with spaces added to increase clarity. The identifier is used internally map an index in input lists to the equivalent index in the results. Can be any string of characters in a-z, A-Z, digits as well as _ (underscore). An example could be MYIDX , which would refer to one index in a list. The range must conform with PathIndexRange and may be used to control the scope of an identifier . An example could be 0 or : . The offset is a signed integer that may be used to offset the affected index. An example could be -1 . Using the examples above the model index specifier would be :@MYIDX-1 . The range and last are optional. A non-empty range requires an empty (i.e. zero) offset and vice versa. To put index specifiers into some context consider a Hubit component that provides cars[IDX_CAR].parts[:@IDX_PART].name . This path tells Hubit that the names of all parts of a specific car can be provided. Let us break down the path and take a closer look at the index specifers in square brackets. The index specifier :@IDX_PART refers to all elements of the parts list (using the range : ) and defines the identifier ( IDX_PART ) to represent elements of the parts list. So in this case, the index specifier contains both a range and an identifier, but no offset. The left-most index specifier IDX_CAR only contains an identifier that represents elements of the cars list. Since no range is specified the identifier refers to a specific car determined by the query (e.g. cars[6].parts[:].name ). cars[IDX_CAR].parts[:@IDX_PART].name therefore references the names of all parts of a specific car which depend on the query specified by the user. A component that consumes this path would have access to these names in a list. The index specifier 0@IDX_PART would always reference element 0 of the parts list irrespective of the query.","title":"ModelIndexSpecifier"},{"location":"config-reference.html#hubit.config.PathIndexRange","text":"In HubitModelPath and HubitQueryPath the supported ranges comprise Positive integers e.g. 0 , 17 . Negative integers e.g. -1 , -2 . The all-index character : . Further, in the index_scope attribute of HubitModelComponent the following ranges are also allowed d: where d is a positive integer e.g. 3: . :d where d is a positive integer e.g. :3 . d1:d2 where d1 and d2 are positive integers and d1 < d2 e.g. 2:5","title":"PathIndexRange"},{"location":"example-car.html","text":"The price of a car In this example we consider a simplified price calculation for a car. The example some basic hubit features and shows three different ways of implementing the car prices calculation. To a large extent, the example follows examples/car . The example will be explained and some key Hubit terminology will be introduced. In the example let us imagine that we are calculating the price of a car based on the names of the individual parts. So the calculation involves a lookup of the price for each part and a summation of the parts prices. Components First, your existing tools each need to be wrapped as a Hubit component . A Hubit component is a computational task that has bindings to the input data and to the results data. The bindings define which attributes the component consumes from the shared input data structure, consumes from the shared results data structure, and provides to the shared results data structure. From the bindings Hubit can check that all required input data and results data is available before the computational task is executed. The bindings are defined in a model configuration file and are passed to the component entrypoint function . Component entrypoint function Below you can see some pseudo code for the calculation for the car price calculation. The example is available in mod1_cmp1.py def price ( _input_consumed , results_provided ): # Extract required input data here counts = _input_consumed [ 'part_counts' ] names = _input_consumed [ 'part_names' ] # Look up the price of the part based on the part name (local data, database) unit_prices = [ my_lookup ( name ) for name in names ] # Compute results here (web service, C, Python ...) result = sum ( [ count * unit_price for count , unit_price in zip ( counts , unit_prices ) ] ) results_provided [ 'car_price' ] = result The entrypoint function in a component ( price in the example above) should expect the arguments _input_consumed and results_provided in that order. Results data calculated in the components should only be added to the latter. The values stored in the keys part_counts and part_names in _input_consumed are controlled by the bindings in the model configuration file. Component bindings Before we look at the bindings let us look at the input data. The input can, like in the example below, be defined in a yml file. In the car example the input data is a list containing two cars each with a number of parts cars : - parts : - count : 4 name : wheel1 - count : 1 name : chassis1 - count : 2 name : bumper - count : 1 name : engine1 - count : 1 name : radio - parts : - count : 4 name : wheel2 - count : 1 name : chassis2 - count : 2 name : bumper - count : 1 name : engine14 The price entrypoint function above expects a list of part names stored in the field part_names and a list of the corresponding part counts stored in the field part_counts . To make such lists available for the entrypoint function, the model configuration file should contain the lines below. consumes_input : - name : part_names # key in _input_consumed exposed to the entrypoint function path : cars[IDX_CAR].parts[:@IDX_PART].name # path in input data - name : part_counts path : cars[IDX_CAR].parts[:@IDX_PART].count The strings in square braces are called index specifiers . The index specifier :@IDX_PART refers to all items for the index identifier IDX_PART . The index specifier IDX_CAR is simply refers to a specific car. The index identifiers (here IDX_PART and IDX_CAR ) are identification strings that the user can choose with some limitations . With the input data and bindings shown above, the content of _input_consumed in the price function for the car at index 1 will be { 'part_counts' : [ 4 , 1 , 2 , 1 ], 'part_names' : [ 'wheel2' , 'chassis2' , 'bumper' , 'engine14' ] } i.e. the component's entrypoint function will have all counts and part names for a single car in this case the car at index 1 available in the input. In the last line of the price function, the car price is added to the results results_provided [ 'car_price' ] = result To enable the transfer of the calculated car price to the correct path in the shared results data object we must add a binding for the name car_price . If, for example, we want to store the car price in a field called price at the same car index as where the input data was taken from, the binding below should be added to the model file. provides_results : - name : car_price # internal name (key) in results_provided path : cars[IDX_CAR].price # path in the shared results data The index specifier IDX_CAR in the binding path tells Hubit to store the car price at the same car index as where the input was taken from. Note that the component itself is unaware of which car (car index) the input represents. Collecting the bindings we get provides_results : - name : car_price # internal name in the component path : cars[IDX_CAR].price # path in the shared data consumes_input : - name : part_name path : cars[IDX_CAR].parts[:@IDX_PART].name - name : part_counts path : cars[IDX_CAR].parts[:@IDX_PART].count Read more about paths , index specifiers and index identifiers in the documentation. Tips on refactoring The flexibility of the Hubit binding paths allows you to match the interfaces of your existing tools. Further, this flexibility enables you to refactor to get good modularity and optimize for speed when multi-processing is used. Below we will show three versions of the car model and outline some key differences when multi-processing is used. Car model 0 In model0.yml the price calculation receives an entire car object at a specific car index ( IDX_CAR ). This allows the component to store results data on the corresponding car index in the results data object that Hubit creates. provides_results : - name : car_price path : cars[IDX_CAR].price consumes_input : - name : car path : cars[IDX_CAR] This model allows queries such as cars[:].price and cars[1].price . If car objects in the input data only contains count and name (like in the example above) this simple model definition is more or less equivalent to the more elaborate model shown above. If, on the other hand, car objects in the input data contains more data this (irrelevant) data would be exposed to the price calculation function. Further, in the implementation of the car price calculation an undesirable tight coupling to the input data structure would be unavoidable. The entrypoint function could look something like this counts , names = list ( zip ( * [( part [ \"count\" ], part [ \"name\" ]) for part in _input_consumed [ \"car\" ][ \"parts\" ]] ) ) unit_prices = [ my_lookup_function ( name ) for name in names ] result = sum ([ count * unit_price for count , unit_price in zip ( counts , unit_prices )]) results_provided [ \"car_price\" ] = result Notice how the parts list and the count and name attributes are accessed directly on the car object leading to a tight coupling. Car model 1 model1.yml is the one described above model 0 where the car price is calculated in a single component i.e. in a single worker process. Such an approach works well if the lookup of parts prices is fast and the car price calculation is also fast. If, however, the lookup is fast while the car price calculation is slow, and we imagine that another component is also consuming the parts prices, then the car price calculation would be a bottleneck. In such cases, separating the lookup from the price calculation would probably boost performance. Models 2 and 3 present two different ways of implementing such a separation. Car model 2 In model2.yml the parts price lookup and the car price calculation are implemented in two separate components. Further, the component that is responsible for the price lookup retrieves the price for one part only. In other words, each lookup will happen in a separate (optionally asynchronous) worker process. When all the lookup processes are done, the price component sums the parts prices to get the total car price. The relevant sections of the model file could look like this # price for one part - consumes_input : - name : part_name path : cars[IDX_CAR].parts[IDX_PART].name - name : part_count path : cars[IDX_CAR].parts[IDX_PART].count provides_results : - name : part_price path : cars[IDX_CAR].parts[IDX_PART].price # car price from parts prices - consumes_results : - name : prices path : cars[IDX_CAR].parts[:@IDX_PART].price provides_results : - name : car_price path : cars[IDX_CAR].price Notice that the first component consumes a specific part index ( IDX_PART ) for a specific car index ( IDX_CAR ). This allows the component to store results data on a specific part index for a specific car index. The entrypoint function for the first component (price for one part) could look something like this def part_price ( _input_consumed , results_provided ): count = _input_consumed [ 'part_count' ] name = _input_consumed [ 'part_name' ] results_provided [ 'part_price' ] = count * my_lookup_function ( name ) The entrypoint function for the second component (car price) could look like this def car_price ( _input_consumed , results_provided ): results_provided [ 'car_price' ] = sum ( _input_consumed [ 'prices' ] ) In this refactored model Hubit will, when submitting a query for the car price using the multi-processor flag, execute each part price calculation in a separate asynchronous worker process. If the part price lookup is fast, the overhead introduced by multi-processing may be render model 2 less attractive. In such cases performing all the lookups in a single component, but still keeping the lookup separate from the car price calculation, as shown in car model 3, could be a good solution. Car model 3 In model3.yml all price lookups take place in one single component and the car price calculation takes place in another component. For the lookup component, the relevant sections of the model file could look like this # price for all parts consumes_input : - name : parts_name path : cars[IDX_CAR].parts[:@IDX_PART].name - name : parts_count path : cars[IDX_CAR].parts[:@IDX_PART].count provides_results : - name : parts_price path : cars[IDX_CAR].parts[:@IDX_PART].price Notice that the component consumes all part indices ( :@IDX_PART ) for a specific car index ( IDX_CAR ). This allows the component to store results data on all part indices for a specific car index. The entrypoint for the first component (price for all parts) could look something like this def part_price ( _input_consumed , results_provided ): counts = _input_consumed [ 'parts_count' ] names = _input_consumed [ 'parts_name' ] results_provided [ 'parts_price' ] = [ count * my_lookup_function ( name ) for count , name in zip ( counts , names ) ] In this model, the car price component is identical to the one used in model 2 and is therefore omitted here. Path to the entrypoint function To tie together the bindings with the the Python code that does the actual work you need to add the path of the Python source code file to the model file. For the first car model it could look like this. - path : ./components/price1.py func_name : price provides_results : - name : car_price path : cars[IDX_CAR].price consumes_input : - name : part_names path : cars[IDX_CAR].parts[:@IDX_PART].name - name : part_counts path : cars[IDX_CAR].parts[:@IDX_PART].count The specified path should be relative to model's base_path attribute, which defaults to the location of the model file when the model is initialized using the from_file method. You can also use a dotted path e.g. path : hubit_components.price1 is_dotted_path : True where hubit_components would typically be a package you have installed in site-packages. Running To get results from a model requires you to submit a query . After Hubit has processed the query the values of the queried attributes are returned in the response . A query may spawn many component workers that may each represent an instance of the same or different model components. Below are two examples of queries and the corresponding responses. # Load model from file hmodel = HubitModel . from_file ( 'model1.yml' , name = 'car' ) # Load the input with open ( os . path . join ( THISPATH , \"input.yml\" ), \"r\" ) as stream : input_data = yaml . load ( stream , Loader = yaml . FullLoader ) # Set the input on the model object hmodel . set_input ( input_data ) # Query the model query = [ 'cars[0].price' ] response = hmodel . get ( query ) The response looks like this { 'cars[0].price' : 4280.0 } Is this case the parts prices will also be calculated by Hubit to create the response. A query for parts prices for all cars looks like this query = [ 'cars[:].parts[:].price' ] response = hmodel . get ( query ) and the corresponding response is { 'cars[:].parts[:].price' : [ [ 480.0 , 1234.0 , 178.0 , 2343.0 , 45.0 ], [ 312.0 , 1120.0 , 178.0 , 3400.0 ] ] } Rendering If Graphviz is installed Hubit can render models and queries. In the example below we have rendered the query [cars[0].price] i.e. the price of the car at index 0. The graph illustrates nodes in the input data structure, nodes in the the results data structure, the calculation components involved in creating the response as well as hints at which attributes flow in and out of these components. The triple bar icon \u2261 indicates that the node is accessed by index and should therefore be a list. The graph was created using the command below. query = [ 'cars[0].price' ] hmodel . render ( query ) Validation Running hmodel . validate () will validate various aspects of the model. Running hmodel . validate ([ 'cars[0].price' ]) will validate various aspects of the query. Caching Model-level caching By default Hubit never caches results internally. A Hubit model can, however, write results to disk automatically by using the set_model_caching method to set the caching level. Results caching is useful when you want to avoid spending time calculating the same results multiple times or to have Hubit create restart snapshots. The table below comes from printing the log after running model 2 with and without model-level caching print ( hmodel . log ()) -------------------------------------------------------------------------------------------------- Query finish time Query took (s) Worker name Workers spawned Component cache hits -------------------------------------------------------------------------------------------------- 21-Mar-2021 20:46:31 0.1 car_price 0 0 part_price 0 0 21-Mar-2021 20:46:31 1.8 car_price 3 0 part_price 14 0 -------------------------------------------------------------------------------------------------- The second run (top) using the cache is much faster than the first run (bottom) that spawns 17 workers to complete the query. The model cache can be cleared using the clear_cache method on a Hubit model. To check if a model has an associated cached result use has_cached_results method on a Hubit model. Cached results for all models can be cleared by using hubit.clear_hubit_cache() . Component-level caching Component-level caching can be activated using set_component_caching . By default component-level caching is off. If component-level caching is on, the consumed data for all spawned component workers and the corresponding results will be stored in memory during execution of a query. If Hubit finds that, in the same query, two workers refer to the same model component and the input data are identical, the second worker will simply use the results produced by the first worker. The cache is not shared between sequential queries to a model. Also, the component-level cache is not shared between the individual sampling runs using get_many method. The table below comes from printing the log after running car model 2 with and without component-level caching print ( hmodel . log ()) -------------------------------------------------------------------------------------------------- Query finish time Query took (s) Worker name Workers spawned Component cache hits -------------------------------------------------------------------------------------------------- 21-Mar-2021 20:48:26 1.1 car_price 3 1 part_price 14 6 21-Mar-2021 20:48:25 1.8 car_price 3 0 part_price 14 0 -------------------------------------------------------------------------------------------------- The second run (top) uses component-caching and is faster than the first run (bottom). Both queries spawn 17 workers in order to complete the query, but in the case where component-caching is active (top) 7 workers reuse results provided by the remaining 10 workers. For smaller jobs any speed-up obtained my using component-level caching cannot be seen on the wall clock when using multi-processing. The effect will, however, be apparent in the model log as seen above.","title":"Car"},{"location":"example-car.html#the-price-of-a-car","text":"In this example we consider a simplified price calculation for a car. The example some basic hubit features and shows three different ways of implementing the car prices calculation. To a large extent, the example follows examples/car . The example will be explained and some key Hubit terminology will be introduced. In the example let us imagine that we are calculating the price of a car based on the names of the individual parts. So the calculation involves a lookup of the price for each part and a summation of the parts prices.","title":"The price of a car"},{"location":"example-car.html#components","text":"First, your existing tools each need to be wrapped as a Hubit component . A Hubit component is a computational task that has bindings to the input data and to the results data. The bindings define which attributes the component consumes from the shared input data structure, consumes from the shared results data structure, and provides to the shared results data structure. From the bindings Hubit can check that all required input data and results data is available before the computational task is executed. The bindings are defined in a model configuration file and are passed to the component entrypoint function .","title":"Components"},{"location":"example-car.html#component-entrypoint-function","text":"Below you can see some pseudo code for the calculation for the car price calculation. The example is available in mod1_cmp1.py def price ( _input_consumed , results_provided ): # Extract required input data here counts = _input_consumed [ 'part_counts' ] names = _input_consumed [ 'part_names' ] # Look up the price of the part based on the part name (local data, database) unit_prices = [ my_lookup ( name ) for name in names ] # Compute results here (web service, C, Python ...) result = sum ( [ count * unit_price for count , unit_price in zip ( counts , unit_prices ) ] ) results_provided [ 'car_price' ] = result The entrypoint function in a component ( price in the example above) should expect the arguments _input_consumed and results_provided in that order. Results data calculated in the components should only be added to the latter. The values stored in the keys part_counts and part_names in _input_consumed are controlled by the bindings in the model configuration file.","title":"Component entrypoint function"},{"location":"example-car.html#component-bindings","text":"Before we look at the bindings let us look at the input data. The input can, like in the example below, be defined in a yml file. In the car example the input data is a list containing two cars each with a number of parts cars : - parts : - count : 4 name : wheel1 - count : 1 name : chassis1 - count : 2 name : bumper - count : 1 name : engine1 - count : 1 name : radio - parts : - count : 4 name : wheel2 - count : 1 name : chassis2 - count : 2 name : bumper - count : 1 name : engine14 The price entrypoint function above expects a list of part names stored in the field part_names and a list of the corresponding part counts stored in the field part_counts . To make such lists available for the entrypoint function, the model configuration file should contain the lines below. consumes_input : - name : part_names # key in _input_consumed exposed to the entrypoint function path : cars[IDX_CAR].parts[:@IDX_PART].name # path in input data - name : part_counts path : cars[IDX_CAR].parts[:@IDX_PART].count The strings in square braces are called index specifiers . The index specifier :@IDX_PART refers to all items for the index identifier IDX_PART . The index specifier IDX_CAR is simply refers to a specific car. The index identifiers (here IDX_PART and IDX_CAR ) are identification strings that the user can choose with some limitations . With the input data and bindings shown above, the content of _input_consumed in the price function for the car at index 1 will be { 'part_counts' : [ 4 , 1 , 2 , 1 ], 'part_names' : [ 'wheel2' , 'chassis2' , 'bumper' , 'engine14' ] } i.e. the component's entrypoint function will have all counts and part names for a single car in this case the car at index 1 available in the input. In the last line of the price function, the car price is added to the results results_provided [ 'car_price' ] = result To enable the transfer of the calculated car price to the correct path in the shared results data object we must add a binding for the name car_price . If, for example, we want to store the car price in a field called price at the same car index as where the input data was taken from, the binding below should be added to the model file. provides_results : - name : car_price # internal name (key) in results_provided path : cars[IDX_CAR].price # path in the shared results data The index specifier IDX_CAR in the binding path tells Hubit to store the car price at the same car index as where the input was taken from. Note that the component itself is unaware of which car (car index) the input represents. Collecting the bindings we get provides_results : - name : car_price # internal name in the component path : cars[IDX_CAR].price # path in the shared data consumes_input : - name : part_name path : cars[IDX_CAR].parts[:@IDX_PART].name - name : part_counts path : cars[IDX_CAR].parts[:@IDX_PART].count Read more about paths , index specifiers and index identifiers in the documentation.","title":"Component bindings"},{"location":"example-car.html#tips-on-refactoring","text":"The flexibility of the Hubit binding paths allows you to match the interfaces of your existing tools. Further, this flexibility enables you to refactor to get good modularity and optimize for speed when multi-processing is used. Below we will show three versions of the car model and outline some key differences when multi-processing is used.","title":"Tips on refactoring"},{"location":"example-car.html#car-model-0","text":"In model0.yml the price calculation receives an entire car object at a specific car index ( IDX_CAR ). This allows the component to store results data on the corresponding car index in the results data object that Hubit creates. provides_results : - name : car_price path : cars[IDX_CAR].price consumes_input : - name : car path : cars[IDX_CAR] This model allows queries such as cars[:].price and cars[1].price . If car objects in the input data only contains count and name (like in the example above) this simple model definition is more or less equivalent to the more elaborate model shown above. If, on the other hand, car objects in the input data contains more data this (irrelevant) data would be exposed to the price calculation function. Further, in the implementation of the car price calculation an undesirable tight coupling to the input data structure would be unavoidable. The entrypoint function could look something like this counts , names = list ( zip ( * [( part [ \"count\" ], part [ \"name\" ]) for part in _input_consumed [ \"car\" ][ \"parts\" ]] ) ) unit_prices = [ my_lookup_function ( name ) for name in names ] result = sum ([ count * unit_price for count , unit_price in zip ( counts , unit_prices )]) results_provided [ \"car_price\" ] = result Notice how the parts list and the count and name attributes are accessed directly on the car object leading to a tight coupling.","title":"Car model 0"},{"location":"example-car.html#car-model-1","text":"model1.yml is the one described above model 0 where the car price is calculated in a single component i.e. in a single worker process. Such an approach works well if the lookup of parts prices is fast and the car price calculation is also fast. If, however, the lookup is fast while the car price calculation is slow, and we imagine that another component is also consuming the parts prices, then the car price calculation would be a bottleneck. In such cases, separating the lookup from the price calculation would probably boost performance. Models 2 and 3 present two different ways of implementing such a separation.","title":"Car model 1"},{"location":"example-car.html#car-model-2","text":"In model2.yml the parts price lookup and the car price calculation are implemented in two separate components. Further, the component that is responsible for the price lookup retrieves the price for one part only. In other words, each lookup will happen in a separate (optionally asynchronous) worker process. When all the lookup processes are done, the price component sums the parts prices to get the total car price. The relevant sections of the model file could look like this # price for one part - consumes_input : - name : part_name path : cars[IDX_CAR].parts[IDX_PART].name - name : part_count path : cars[IDX_CAR].parts[IDX_PART].count provides_results : - name : part_price path : cars[IDX_CAR].parts[IDX_PART].price # car price from parts prices - consumes_results : - name : prices path : cars[IDX_CAR].parts[:@IDX_PART].price provides_results : - name : car_price path : cars[IDX_CAR].price Notice that the first component consumes a specific part index ( IDX_PART ) for a specific car index ( IDX_CAR ). This allows the component to store results data on a specific part index for a specific car index. The entrypoint function for the first component (price for one part) could look something like this def part_price ( _input_consumed , results_provided ): count = _input_consumed [ 'part_count' ] name = _input_consumed [ 'part_name' ] results_provided [ 'part_price' ] = count * my_lookup_function ( name ) The entrypoint function for the second component (car price) could look like this def car_price ( _input_consumed , results_provided ): results_provided [ 'car_price' ] = sum ( _input_consumed [ 'prices' ] ) In this refactored model Hubit will, when submitting a query for the car price using the multi-processor flag, execute each part price calculation in a separate asynchronous worker process. If the part price lookup is fast, the overhead introduced by multi-processing may be render model 2 less attractive. In such cases performing all the lookups in a single component, but still keeping the lookup separate from the car price calculation, as shown in car model 3, could be a good solution.","title":"Car model 2"},{"location":"example-car.html#car-model-3","text":"In model3.yml all price lookups take place in one single component and the car price calculation takes place in another component. For the lookup component, the relevant sections of the model file could look like this # price for all parts consumes_input : - name : parts_name path : cars[IDX_CAR].parts[:@IDX_PART].name - name : parts_count path : cars[IDX_CAR].parts[:@IDX_PART].count provides_results : - name : parts_price path : cars[IDX_CAR].parts[:@IDX_PART].price Notice that the component consumes all part indices ( :@IDX_PART ) for a specific car index ( IDX_CAR ). This allows the component to store results data on all part indices for a specific car index. The entrypoint for the first component (price for all parts) could look something like this def part_price ( _input_consumed , results_provided ): counts = _input_consumed [ 'parts_count' ] names = _input_consumed [ 'parts_name' ] results_provided [ 'parts_price' ] = [ count * my_lookup_function ( name ) for count , name in zip ( counts , names ) ] In this model, the car price component is identical to the one used in model 2 and is therefore omitted here.","title":"Car model 3"},{"location":"example-car.html#path-to-the-entrypoint-function","text":"To tie together the bindings with the the Python code that does the actual work you need to add the path of the Python source code file to the model file. For the first car model it could look like this. - path : ./components/price1.py func_name : price provides_results : - name : car_price path : cars[IDX_CAR].price consumes_input : - name : part_names path : cars[IDX_CAR].parts[:@IDX_PART].name - name : part_counts path : cars[IDX_CAR].parts[:@IDX_PART].count The specified path should be relative to model's base_path attribute, which defaults to the location of the model file when the model is initialized using the from_file method. You can also use a dotted path e.g. path : hubit_components.price1 is_dotted_path : True where hubit_components would typically be a package you have installed in site-packages.","title":"Path to the entrypoint function"},{"location":"example-car.html#running","text":"To get results from a model requires you to submit a query . After Hubit has processed the query the values of the queried attributes are returned in the response . A query may spawn many component workers that may each represent an instance of the same or different model components. Below are two examples of queries and the corresponding responses. # Load model from file hmodel = HubitModel . from_file ( 'model1.yml' , name = 'car' ) # Load the input with open ( os . path . join ( THISPATH , \"input.yml\" ), \"r\" ) as stream : input_data = yaml . load ( stream , Loader = yaml . FullLoader ) # Set the input on the model object hmodel . set_input ( input_data ) # Query the model query = [ 'cars[0].price' ] response = hmodel . get ( query ) The response looks like this { 'cars[0].price' : 4280.0 } Is this case the parts prices will also be calculated by Hubit to create the response. A query for parts prices for all cars looks like this query = [ 'cars[:].parts[:].price' ] response = hmodel . get ( query ) and the corresponding response is { 'cars[:].parts[:].price' : [ [ 480.0 , 1234.0 , 178.0 , 2343.0 , 45.0 ], [ 312.0 , 1120.0 , 178.0 , 3400.0 ] ] }","title":"Running"},{"location":"example-car.html#rendering","text":"If Graphviz is installed Hubit can render models and queries. In the example below we have rendered the query [cars[0].price] i.e. the price of the car at index 0. The graph illustrates nodes in the input data structure, nodes in the the results data structure, the calculation components involved in creating the response as well as hints at which attributes flow in and out of these components. The triple bar icon \u2261 indicates that the node is accessed by index and should therefore be a list. The graph was created using the command below. query = [ 'cars[0].price' ] hmodel . render ( query )","title":"Rendering"},{"location":"example-car.html#validation","text":"Running hmodel . validate () will validate various aspects of the model. Running hmodel . validate ([ 'cars[0].price' ]) will validate various aspects of the query.","title":"Validation"},{"location":"example-car.html#caching","text":"","title":"Caching"},{"location":"example-car.html#model-level-caching","text":"By default Hubit never caches results internally. A Hubit model can, however, write results to disk automatically by using the set_model_caching method to set the caching level. Results caching is useful when you want to avoid spending time calculating the same results multiple times or to have Hubit create restart snapshots. The table below comes from printing the log after running model 2 with and without model-level caching print ( hmodel . log ()) -------------------------------------------------------------------------------------------------- Query finish time Query took (s) Worker name Workers spawned Component cache hits -------------------------------------------------------------------------------------------------- 21-Mar-2021 20:46:31 0.1 car_price 0 0 part_price 0 0 21-Mar-2021 20:46:31 1.8 car_price 3 0 part_price 14 0 -------------------------------------------------------------------------------------------------- The second run (top) using the cache is much faster than the first run (bottom) that spawns 17 workers to complete the query. The model cache can be cleared using the clear_cache method on a Hubit model. To check if a model has an associated cached result use has_cached_results method on a Hubit model. Cached results for all models can be cleared by using hubit.clear_hubit_cache() .","title":"Model-level caching"},{"location":"example-car.html#component-level-caching","text":"Component-level caching can be activated using set_component_caching . By default component-level caching is off. If component-level caching is on, the consumed data for all spawned component workers and the corresponding results will be stored in memory during execution of a query. If Hubit finds that, in the same query, two workers refer to the same model component and the input data are identical, the second worker will simply use the results produced by the first worker. The cache is not shared between sequential queries to a model. Also, the component-level cache is not shared between the individual sampling runs using get_many method. The table below comes from printing the log after running car model 2 with and without component-level caching print ( hmodel . log ()) -------------------------------------------------------------------------------------------------- Query finish time Query took (s) Worker name Workers spawned Component cache hits -------------------------------------------------------------------------------------------------- 21-Mar-2021 20:48:26 1.1 car_price 3 1 part_price 14 6 21-Mar-2021 20:48:25 1.8 car_price 3 0 part_price 14 0 -------------------------------------------------------------------------------------------------- The second run (top) uses component-caching and is faster than the first run (bottom). Both queries spawn 17 workers in order to complete the query, but in the case where component-caching is active (top) 7 workers reuse results provided by the remaining 10 workers. For smaller jobs any speed-up obtained my using component-level caching cannot be seen on the wall clock when using multi-processing. The effect will, however, be apparent in the model log as seen above.","title":"Component-level caching"},{"location":"example-tanks.html","text":"Connected tanks This example shows how to set up models where one compartment (cell, element) consumes a result of an upstream compartment (cell, element). In the example, a liquid flows from one tank to the next and encompass two similar tanks models model_1.yml and model_2.yml . The former illustrates explicit linking of the tanks which is useful for unstructured problems while the latter shows a linking pattern useful for structured problems. Notice that all the model components presented below share the same entrypoint function even though the configurations are quite different. This highlights the powerful separation of implementation and configuration in Hubit . Model 1: Unstructured In this example liquid flows into tank 1 with rate Q_in,1 . In tank 1 some process takes place and the yield rate is Q_yield,1 . Tank 2 is similar to tank 1 only the yield rate is Q_yield,2 . The two yield streams are mixed in tank 3 where another process takes place with yield Q_yield,3 . The entire process is schematically illustrated below code { font-family: \"var(--md-code-font-family,_)\",SFMono-Regular,Consolas,Menlo,monospace; } \u2551 Q_in,1 \u2551 Q_in,2 \u2551 \u2551 \u250c\u2500\u2500\u2551\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2551\u2500\u2500\u2510 \u2502 \u02c5 \u2502 | \u02c5 | \u2502 \u2502 | | \u2502~~~~~~~~~~\u2502 |~~~~~~~~| \u2502 Tank 1 \u2502 | Tank 2 | \u2514\u2500\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2565\u2500\u2500\u2518 \u2551 Q_yield,1 Q_yield,2 \u2551 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2557 Q_spill,1 \u2551 \u2551 \u2551 \u2551 Q_spill,2 \u02c5 \u2551 \u2551 \u02c5 \u250c\u2500\u2551\u2500\u2500\u2500\u2500\u2551\u2500\u2510 | \u02c5 \u02c5 | | | |~~~~~~~~| | Tank 3 | \u2514\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2557 Q_spill,3 \u2551 \u2551 Q_yield,3 \u02c5 \u02c5 For simplicity, the yields are determined from a predefined yield fraction parameter i.e. Q_yield = yield_fraction * Q_in . Imagine the three tanks represent a production line on a production site. If we consider only one production site with only one production line, the input for the model could look like this - prod_sites : - prod_lines : tanks : - yield_fraction : 0.5 Q_in : 20. Q_transfer : 0. - yield_fraction : 0.6 Q_in : 10. Q_transfer : 0. - yield_fraction : 0.25 Q_in : 0. The fields prod_sites[0].prod_lines[0].tanks[0:2].Q_transfer: 0 and prod_sites[0].prod_lines[0].tanks[2].Q_in: 0 are boundary conditions that have been added to allow the implementation of the calculation code to be the same for all tanks. Explicit indexing In this example we will use explicit indexing to direct the yield from tank 1 Q_yield,1 into tank 3. For tank 1, the model component could look like this # Tank 1 - path : ./components/mod1.py provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_in - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_transfer We see that, for a given production site ( IDX_SITE ) and a given production line ( IDX_LINE ) on that site, tank 1 consumes input ( yield_fraction , Q_in and Q_transfer ) from element zero in the list of tanks in the input data ( tanks[0@IDX_TANK] ). Similarly, the resulting yield ( Q_yield ) is stored on element zero in the tanks list in the results data. For tank 2, the model component is similar to tank 1 except all index specifiers point to tank index 1 ( 1@IDX_TANK ) and is omitted here. For tank 3 the model component could look like this # Third tank - path : ./components/mod1.py provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[2@IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[2@IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[2@IDX_TANK].Q_in consumes_results : # use outlet flow from tank 0 - name : Q_transfer_1 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_yield # use outlet flow from tank 1 - name : Q_transfer_2 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[1@IDX_TANK].Q_yield The nodes provides_results and consumes_input look a lot like the equivalent nodes for tanks 1 and 2 except that all index specifiers now refer to tank index 2 ( 2@IDX_TANK ). One other important difference is that tank 3 consumes the outlet flows Q_yield from tanks 1 and 2. The complete model definition can be seen in examples/tanks/model_1.yml in the repository. With the model in place we can explore some queries and responses. The final yield (from tank 3) from the first production line at the first production site can be obtained from the query. ['prod_sites[0].prod_lines[0].tanks[2].Q_yield'] and the response is {'prod_sites[0].prod_lines[0].tanks[2].Q_yield': 4.0} The same result would be produced by querying ['prod_sites[0].prod_lines[0].tanks[-1].Q_yield'] From examples/tanks/input.yml we can reconstruct how the result 4.0 was calculated Q_yield,3 = yield_fraction_3 * (yield_fraction_1 * Q_in,1 + yield_fraction_2 * Q_in,2) = 0.25 * (0.5 * 20 + 0.6 * 10) = 4.0 The query spawns three workers i.e. one for each tank. Notice that no explicit looping over tanks is required once the subscriptions are configured in the Hubit model. This allow the developers of the tank model to work isolated on the tank model with less attention to the context in which it will be used. If we query the yield from tank 3 from all production lines at all production sites using ['prod_sites[:].prod_lines[:].tanks[2].Q_yield'] we again get the result 4.0 back (since there is actually only one production site and one production line), but the result is now a double nested list. {'prod_sites[:].prod_lines[:].tanks[2].Q_yield': [[4.0]]} The outer list represents the production sites while the inner list represent the production lines. As before ['prod_sites[:].prod_lines[:].tanks[-1].Q_yield'] would produce the same result. Explicit indexing provides nice flexibility, but it may quickly become tiresome to configure. Further, the model presented above would need to be changed when the number of tanks changes. Of course, this could be done programmatically based on the tank connectivities (mesh of cells/compartments/elements) generated elsewhere. Index scope (tanks 1 & 2) model_1a.yml shows how model 1 can be refactored to one component with no explicit indexes in the binding paths by leveraging an index scope the model components for tanks 1 and 2 - path : ./components/mod1.py index_scope : IDX_TANK : \"0:2\" provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_transfer In this case the scope index_scope.IDX_TANK: \"0:2\" assures that IDX_TANK equals 0 or 1 in all instances of this component. This version of the model is shown in examples/tanks/model_1a.yml . Index scope (tank 3) model_1b.yml leverages index scope to reconfigure tank 3 - path : ./components/mod1.py index scope : IDX_TANK : 2 provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in consumes_results : # use outlet flow from previous tank 0 - name : Q_transfer_1 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_yield # use outlet flow from previous tank 1 - name : Q_transfer_2 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[1@IDX_TANK].Q_yield In this case the index scope index_scope.IDX_TANK: 2 assures that the identifier IDX_TANK equals 2 in all instances of this component. The explicit indices in consumes_results i.e. 0@IDX_TANK and 1@IDX_TANK are still used as is. This version of the model is shown in examples/tanks/model_1b.yml . Model 2: Structured In structured cases, such as the tank example schematically illustrated below, Hubit 's index scope and index offset come in handy. \u2551 Q_in,1 \u2551 \u250c\u2500\u2500\u2551\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u02c5 \u2502 \u2502 \u2502 \u2502~~~~~~~~~~\u2502 \u2502 Tank 1 \u2502 \u2551 Q_in,2 \u2514\u2500\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 \u2551 Q_yield,1 \u250c\u2500\u2500\u2500\u2500\u2500\u2551\u2500\u2500\u2510 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550|\u2550\u2557 \u02c5 | Q_spill,1 \u2551 | \u02c5 | \u02c5 |~~~~~~~~| | Tank 2 | \u2551 Q_in,3 \u2514\u2500\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2518 \u2551 \u2551 Q_yield,2 \u250c\u2500\u2500\u2500\u2500\u2500\u2551\u2500\u2500\u2510 Q_spill,2 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550|\u2550\u2557 \u02c5 | \u2551 | \u02c5 | \u02c5 |~~~~~~~~| | Tank 3 | \u2514\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 Q_spill,3 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2557 \u2551 \u02c5 Q_yield,3 \u02c5 The input is the same as in the previous section. Index scope Using an index scope, the component for the first tank may be defined as shown below - path : ./components/mod1.py index_scope : IDX_TANK : 0 provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_transfer At first sight the component looks as if its binding paths can refer to any combination of IDX_SITE , IDX_LINE and IDX_TANK . The index_scope filed, however, assures that IDX_TANK is 0 in all instances of this component. Index offsets The second component is shown below - path : ./components/mod1.py index_scope : IDX_TANK : \"1:\" provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in consumes_results : - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK-1].Q_yield There are two important details. First, the index_scope field limits the scope to tanks after the first tank in all instances of this component. Second, the component consumes the yield rate Q_yield from the previous tank pointing to the index identifier IDX_TANK offset by 1 i.e IDX_TANK-1 . To avoid going out of bounds it is important to exclude the first tank from the index scope as explained above. The complete model definition can be seen in examples/tanks/model_2.yml in the repository. Indexing from the back in the model If we want to use the yield stream from the last tank to calculate e.g. the revenue from a production line we can easily add two components to the model (see e.g. examples/tanks/model_1.yml . The first component, which is implemented in unit_price.py , is responsible for fetching the unit price for the product stream. The second component, which is implemented in revenue.py , subscribes to the yield stream from the last tank as well as the unit price. The latter is responsible for calculating the revenue. The new section in the model file could look like this - path : ./components/unit_price.py provides_results : - name : unit_price path : unit_price consumes_input : - name : url path : price_source - path : ./components/revenue.py provides_results : - name : revenue path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].revenue consumes_results : # use outlet flow from last tank - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[-1@IDX_TANK].Q_yield - name : unit_price path : unit_price In the example unit_price.py uses a web service with a URL defined in the field price_source in the examples/tanks/input.yml .","title":"Tanks"},{"location":"example-tanks.html#connected-tanks","text":"This example shows how to set up models where one compartment (cell, element) consumes a result of an upstream compartment (cell, element). In the example, a liquid flows from one tank to the next and encompass two similar tanks models model_1.yml and model_2.yml . The former illustrates explicit linking of the tanks which is useful for unstructured problems while the latter shows a linking pattern useful for structured problems. Notice that all the model components presented below share the same entrypoint function even though the configurations are quite different. This highlights the powerful separation of implementation and configuration in Hubit .","title":"Connected tanks"},{"location":"example-tanks.html#model-1-unstructured","text":"In this example liquid flows into tank 1 with rate Q_in,1 . In tank 1 some process takes place and the yield rate is Q_yield,1 . Tank 2 is similar to tank 1 only the yield rate is Q_yield,2 . The two yield streams are mixed in tank 3 where another process takes place with yield Q_yield,3 . The entire process is schematically illustrated below code { font-family: \"var(--md-code-font-family,_)\",SFMono-Regular,Consolas,Menlo,monospace; } \u2551 Q_in,1 \u2551 Q_in,2 \u2551 \u2551 \u250c\u2500\u2500\u2551\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2551\u2500\u2500\u2510 \u2502 \u02c5 \u2502 | \u02c5 | \u2502 \u2502 | | \u2502~~~~~~~~~~\u2502 |~~~~~~~~| \u2502 Tank 1 \u2502 | Tank 2 | \u2514\u2500\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2565\u2500\u2500\u2518 \u2551 Q_yield,1 Q_yield,2 \u2551 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557 \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2569\u2550\u2550\u2557 Q_spill,1 \u2551 \u2551 \u2551 \u2551 Q_spill,2 \u02c5 \u2551 \u2551 \u02c5 \u250c\u2500\u2551\u2500\u2500\u2500\u2500\u2551\u2500\u2510 | \u02c5 \u02c5 | | | |~~~~~~~~| | Tank 3 | \u2514\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2557 Q_spill,3 \u2551 \u2551 Q_yield,3 \u02c5 \u02c5 For simplicity, the yields are determined from a predefined yield fraction parameter i.e. Q_yield = yield_fraction * Q_in . Imagine the three tanks represent a production line on a production site. If we consider only one production site with only one production line, the input for the model could look like this - prod_sites : - prod_lines : tanks : - yield_fraction : 0.5 Q_in : 20. Q_transfer : 0. - yield_fraction : 0.6 Q_in : 10. Q_transfer : 0. - yield_fraction : 0.25 Q_in : 0. The fields prod_sites[0].prod_lines[0].tanks[0:2].Q_transfer: 0 and prod_sites[0].prod_lines[0].tanks[2].Q_in: 0 are boundary conditions that have been added to allow the implementation of the calculation code to be the same for all tanks.","title":"Model 1: Unstructured"},{"location":"example-tanks.html#explicit-indexing","text":"In this example we will use explicit indexing to direct the yield from tank 1 Q_yield,1 into tank 3. For tank 1, the model component could look like this # Tank 1 - path : ./components/mod1.py provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_in - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_transfer We see that, for a given production site ( IDX_SITE ) and a given production line ( IDX_LINE ) on that site, tank 1 consumes input ( yield_fraction , Q_in and Q_transfer ) from element zero in the list of tanks in the input data ( tanks[0@IDX_TANK] ). Similarly, the resulting yield ( Q_yield ) is stored on element zero in the tanks list in the results data. For tank 2, the model component is similar to tank 1 except all index specifiers point to tank index 1 ( 1@IDX_TANK ) and is omitted here. For tank 3 the model component could look like this # Third tank - path : ./components/mod1.py provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[2@IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[2@IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[2@IDX_TANK].Q_in consumes_results : # use outlet flow from tank 0 - name : Q_transfer_1 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_yield # use outlet flow from tank 1 - name : Q_transfer_2 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[1@IDX_TANK].Q_yield The nodes provides_results and consumes_input look a lot like the equivalent nodes for tanks 1 and 2 except that all index specifiers now refer to tank index 2 ( 2@IDX_TANK ). One other important difference is that tank 3 consumes the outlet flows Q_yield from tanks 1 and 2. The complete model definition can be seen in examples/tanks/model_1.yml in the repository. With the model in place we can explore some queries and responses. The final yield (from tank 3) from the first production line at the first production site can be obtained from the query. ['prod_sites[0].prod_lines[0].tanks[2].Q_yield'] and the response is {'prod_sites[0].prod_lines[0].tanks[2].Q_yield': 4.0} The same result would be produced by querying ['prod_sites[0].prod_lines[0].tanks[-1].Q_yield'] From examples/tanks/input.yml we can reconstruct how the result 4.0 was calculated Q_yield,3 = yield_fraction_3 * (yield_fraction_1 * Q_in,1 + yield_fraction_2 * Q_in,2) = 0.25 * (0.5 * 20 + 0.6 * 10) = 4.0 The query spawns three workers i.e. one for each tank. Notice that no explicit looping over tanks is required once the subscriptions are configured in the Hubit model. This allow the developers of the tank model to work isolated on the tank model with less attention to the context in which it will be used. If we query the yield from tank 3 from all production lines at all production sites using ['prod_sites[:].prod_lines[:].tanks[2].Q_yield'] we again get the result 4.0 back (since there is actually only one production site and one production line), but the result is now a double nested list. {'prod_sites[:].prod_lines[:].tanks[2].Q_yield': [[4.0]]} The outer list represents the production sites while the inner list represent the production lines. As before ['prod_sites[:].prod_lines[:].tanks[-1].Q_yield'] would produce the same result. Explicit indexing provides nice flexibility, but it may quickly become tiresome to configure. Further, the model presented above would need to be changed when the number of tanks changes. Of course, this could be done programmatically based on the tank connectivities (mesh of cells/compartments/elements) generated elsewhere.","title":"Explicit indexing"},{"location":"example-tanks.html#index-scope-tanks-1-2","text":"model_1a.yml shows how model 1 can be refactored to one component with no explicit indexes in the binding paths by leveraging an index scope the model components for tanks 1 and 2 - path : ./components/mod1.py index_scope : IDX_TANK : \"0:2\" provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_transfer In this case the scope index_scope.IDX_TANK: \"0:2\" assures that IDX_TANK equals 0 or 1 in all instances of this component. This version of the model is shown in examples/tanks/model_1a.yml .","title":"Index scope (tanks 1 &amp; 2)"},{"location":"example-tanks.html#index-scope-tank-3","text":"model_1b.yml leverages index scope to reconfigure tank 3 - path : ./components/mod1.py index scope : IDX_TANK : 2 provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in consumes_results : # use outlet flow from previous tank 0 - name : Q_transfer_1 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[0@IDX_TANK].Q_yield # use outlet flow from previous tank 1 - name : Q_transfer_2 path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[1@IDX_TANK].Q_yield In this case the index scope index_scope.IDX_TANK: 2 assures that the identifier IDX_TANK equals 2 in all instances of this component. The explicit indices in consumes_results i.e. 0@IDX_TANK and 1@IDX_TANK are still used as is. This version of the model is shown in examples/tanks/model_1b.yml .","title":"Index scope (tank 3)"},{"location":"example-tanks.html#model-2-structured","text":"In structured cases, such as the tank example schematically illustrated below, Hubit 's index scope and index offset come in handy. \u2551 Q_in,1 \u2551 \u250c\u2500\u2500\u2551\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 \u02c5 \u2502 \u2502 \u2502 \u2502~~~~~~~~~~\u2502 \u2502 Tank 1 \u2502 \u2551 Q_in,2 \u2514\u2500\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 \u2551 Q_yield,1 \u250c\u2500\u2500\u2500\u2500\u2500\u2551\u2500\u2500\u2510 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550|\u2550\u2557 \u02c5 | Q_spill,1 \u2551 | \u02c5 | \u02c5 |~~~~~~~~| | Tank 2 | \u2551 Q_in,3 \u2514\u2500\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2518 \u2551 \u2551 Q_yield,2 \u250c\u2500\u2500\u2500\u2500\u2500\u2551\u2500\u2500\u2510 Q_spill,2 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550|\u2550\u2557 \u02c5 | \u2551 | \u02c5 | \u02c5 |~~~~~~~~| | Tank 3 | \u2514\u2500\u2500\u2565\u2500\u2500\u2500\u2500\u2500\u2518 \u2551 Q_spill,3 \u2554\u2550\u2569\u2550\u2550\u2550\u2550\u2557 \u2551 \u02c5 Q_yield,3 \u02c5 The input is the same as in the previous section.","title":"Model 2: Structured"},{"location":"example-tanks.html#index-scope","text":"Using an index scope, the component for the first tank may be defined as shown below - path : ./components/mod1.py index_scope : IDX_TANK : 0 provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_transfer At first sight the component looks as if its binding paths can refer to any combination of IDX_SITE , IDX_LINE and IDX_TANK . The index_scope filed, however, assures that IDX_TANK is 0 in all instances of this component.","title":"Index scope"},{"location":"example-tanks.html#index-offsets","text":"The second component is shown below - path : ./components/mod1.py index_scope : IDX_TANK : \"1:\" provides_results : - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_yield consumes_input : - name : yield_fraction path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].yield_fraction - name : Q_in path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK].Q_in consumes_results : - name : Q_transfer path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[IDX_TANK-1].Q_yield There are two important details. First, the index_scope field limits the scope to tanks after the first tank in all instances of this component. Second, the component consumes the yield rate Q_yield from the previous tank pointing to the index identifier IDX_TANK offset by 1 i.e IDX_TANK-1 . To avoid going out of bounds it is important to exclude the first tank from the index scope as explained above. The complete model definition can be seen in examples/tanks/model_2.yml in the repository.","title":"Index offsets"},{"location":"example-tanks.html#indexing-from-the-back-in-the-model","text":"If we want to use the yield stream from the last tank to calculate e.g. the revenue from a production line we can easily add two components to the model (see e.g. examples/tanks/model_1.yml . The first component, which is implemented in unit_price.py , is responsible for fetching the unit price for the product stream. The second component, which is implemented in revenue.py , subscribes to the yield stream from the last tank as well as the unit price. The latter is responsible for calculating the revenue. The new section in the model file could look like this - path : ./components/unit_price.py provides_results : - name : unit_price path : unit_price consumes_input : - name : url path : price_source - path : ./components/revenue.py provides_results : - name : revenue path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].revenue consumes_results : # use outlet flow from last tank - name : Q_yield path : prod_sites[IDX_SITE].prod_lines[IDX_LINE].tanks[-1@IDX_TANK].Q_yield - name : unit_price path : unit_price In the example unit_price.py uses a web service with a URL defined in the field price_source in the examples/tanks/input.yml .","title":"Indexing from the back in the model"},{"location":"example-wall.html","text":"Heat flow through a wall In this example we consider a wall that consists of three segments as shown in the illustration below. Face view wall (not to scale) _______________ | segment 1 | 1.5 m |_______________| | | | segment 2 | 2.0 m |_______________| | | | segment 3 | 2.0 m |_______________| 3.0 m Each wall segment consists of different layers as shown in the side view below. Side view of the wall (not to scale) brick air rockwool | | | brick | | | | Inside v v v v Outside ---------------------- | | | | | segment 1 (wall: brick-air-rockwool-brick) temperature = 320 K | | | | | temperature = 273 K ---------------------- || || || || segment 2 (window: glass-air-glass) temperature = 300 K || || temperature = 273 K ---------------------- | | | | | | | | segment 3 (wall: concrete-EPS-concrete) temperature = 300 K | | | | temperature = 273 K ---------------------- ^ ^ ^ | | | concrete | concrete EPS The wall materials, dimensions and other input can be found in wall input file examples/wall/input.yml . Note that the number of wall layers in the two segments differ, which illustrates that Hubit can handle non-rectangular data. Model The wall model is defined in examples/wall/model.yml and define bindings between calculation components that provides certain results. The components are explained in greater detail later. With the model in place Hubit allows users to query the results data structure. For example, to get the \"total_cost\" and \"total_heat_loss\" for the wall we would write from hubit.model import HubitModel hmodel = HubitModel . from_file ( 'model.yml' , name = 'wall' ) query = [ \"total_cost\" , \"heat_transfer_number\" ] response = hmodel . get ( query ) The response to the query is { 'total_cost' : 2365.600380096421 , 'heat_transfer_number' : 0.8888377547279751 } Behind the scenes Hubit constructs and executes the call graph for the query. Only components that provide results that are necessary for constructing the response are spawned. Therefore, the query segment[0].cost would only spawn calculations required to calculate the cost of wall segment 0 while the query total_cost invokes cost calculations for all segments. To understand more about this behavior read the Call graph & multi-processing section below. By using different queries it is straight forward to set up reports for different audiences, each with a customized content, but based on the same model and the same input. Such different reports can service different stakeholders e.g. management, internal design engineers, clients or independent verification agencies. Components The source code for the wall model components can be found in the examples/wall/components folder in the repository and are referenced from the model configuration file . A time delay has been added in some of the components to simulate a heavy computational load or a latency in a web service. The time delay illustrates the asynchronous capabilities in Hubit . Some of the calculation components deals with the physics part of the wall model. These components include thermal_conductivity.py . Simple lookup of thermal conductivities based on the material name. thermal_profile.py . A calculation of the temperature for all wall layers in a segment as well as the heat flux in the segment. We assume one-dimensional heat flow, and thus each segment can be treated independently. heat_flow.py . Calculates the heat flow through a segment. heat_transfer_number.py . Calculates the overall heat transfer number and wall energy classification. The wall energy classification ranges from A to D where A indicates the most insulating wall (best) and D indicates the least insulating wall (worst). Many (all) of the components could have been joined in a single component, but here they are kept as separate components to increase modularity, to assure that any query only spawns a minimum of calculations and to maximize the potential speed-up obtained by multi-processing. The wall cost is calculated by the two components below segment_cost.py . Calculates wall segment cost. In the code notice how segments with type 'window' are handled differently compared to other segments types. total_cost.py . Calculates wall total cost. To support the cost calculations two extra engineering components are included volume.py . Calculates the volume of wall layers. weight.py . Calculates the weight of wall layers. Call graph & multi-processing Hubit is event-driven and components are spawned dynamically. The bindings that are used to set up the relations between components are defined in model.yml To illustrate the cascade of events that spawn the necessary calculations let us consider a query for the wall total_cost . In the model file the total cost is provided by total_cost.py . path: ./components/total_cost.py func_name: total_wall_cost provides_results: - name: cost path: total_cost consumes_results: - name: segment_costs path: segments[:@IDX_SEG].cost Further, the model file reveals that the total_cost.py consumes the costs for all segments ( segments[:@IDX_SEG].cost ). The segment costs are, in turn, provided by segment_cost.py as seen from the component definition below, which is also taken from model.yml . path: ./components/segment_cost.py func_name: cost provides_results: - name: cost path: segments[IDX_SEG].cost consumes_input: - name: materials path: segments[IDX_SEG].layers[:@IDX_LAY].material - name: type path: segments[IDX_SEG].type consumes_results: - name: weights path: segments[IDX_SEG].layers[:@IDX_LAY].weight Since the segment costs are not in the results data to begin with Hubit spawns the segment_cost.py calculation. To calculate the segment cost, the material and segment weight must be known for each layer in the segment since these attributes are specified in the consumes_results section. The segment cost component expects the layer materials and weights to be available at segments[IDX_SEG].layers[:@IDX_LAY].material and segments[IDX_SEG].layers[:@IDX_LAY].weight , respectively. The weights are calculated in weight.py and the material (part of the input) is used to look up a price in segment_cost.py . Inspecting model.yml shows that the weight component consumes the layer volume calculated in volume.py . So the original query triggers a cascade of new auxiliary queries that each may spawn new calculations. The calculations are put on hold until the all required data is available. Once this data becomes available the calculation starts and may, after completion, provide data that trigger other pending calculations. Since the cost and heat transfer calculations for each wall segment are independent the event-driven architecture allows Hubit to execute these calculations for each wall segment in parallel if the multi-processing flag is set to True . As we have previously seen, the response to the 'heat_transfer_number' query is { 'heat_transfer_number' : 0.8888377547279751 } All the results that were used to process the query can be accessed using hmodel.results { 'energy_class' : 'C' , 'heat_transfer_number' : 0.8888377547279751 , 'segments' : { 0 : { 'heat_flux' : 13.134093452714046 , 'heat_transfer_number' : 0.2794487968662563 , 'layers' : { 0 : { 'k_therm' : 0.47 , 'outer_temperature' : 317.20551203133743 }, 1 : { 'k_therm' : 0.025 , 'outer_temperature' : 306.6982372691662 }, 2 : { 'k_therm' : 0.034 , 'outer_temperature' : 275.79448796866257 }, 3 : { 'k_therm' : 0.47 , 'outer_temperature' : 273.0 }}}, 1 : { 'heat_flux' : 33.540372670807464 , 'heat_transfer_number' : 1.2422360248447208 , 'layers' : { 0 : { 'k_therm' : 0.8 , 'outer_temperature' : 299.91614906832297 }, 1 : { 'k_therm' : 0.025 , 'outer_temperature' : 273.083850931677 }, 2 : { 'k_therm' : 0.8 , 'outer_temperature' : 272.99999999999994 }}}, 2 : { 'heat_flux' : 26.79699248120301 , 'heat_transfer_number' : 0.9924812030075189 , 'layers' : { 0 : { 'k_therm' : 1.1 , 'outer_temperature' : 296.34586466165416 }, 1 : { 'k_therm' : 0.033 , 'outer_temperature' : 276.0451127819549 }, 2 : { 'k_therm' : 1.1 , 'outer_temperature' : 273.0 }}}}} Example calculations The purpose of the examples are summarized below. To run an example using the hubit source code run the example script from the project root e.g. python3 -m examples.wall.run_queries . In some of the examples you can toggle the multi-processing flag to see the performance difference with and without multi-processing. The performance change obtained by activating multi-processing depends on the time spent in the components. You can try to adjust the sleep time in thermal_conductivity.py and thermal_profile.py . Rending the model To get a graphical overview of a hubit model the model can be rendered if Graphviz is installed . The rendition of the wall model is shown below Hubit can also render a query as illustrated below Notice how the graph representing the query only includes a subset of all the model components. When a query is rendered only the relevant components for that particular query are shown. The example code can be found in examples/wall/render.py . Queries This example runs various queries. First the queries are submitted individually, which causes redundant calculations. Second, all the queries are submitted together in which case Hubit will assure that the same result is not calculate multiple times. An example is shown in examples/wall/run_queries.py . Indexing from the back in the model To illustrate the use of negative indices, the model file includes a component that calculates the minimum temperature between the outermost and second outermost wall layers. The temperature at this interface could be of particular engineering interest. To this end the Hubit model component subscribes to segments[IDX_SEG].layers[-2@IDX_LAY].outer_temperature and the minimum temperature is stored in the path service_layer_minimum_temperature . The example in examples/wall/run_min_temperature.py executes hmodel.get([\"service_layer_minimum_temperature\"]) which gives the response {'service_layer_minimum_temperature': 275.79} . The Hubit log reveals that 10 thermal conductivity and 3 thermal profile workers were spawned to produce the response. ------------------------------------------------------------------------------------------------------------------------------ Query finish time Query took (s) Worker name Workers spawned Component cache hits ------------------------------------------------------------------------------------------------------------------------------- 14-Mar-2022 13:06:16 2.5 ./components/heat_flow.heat_flow 0 0 ./components/heat_transfer_number.heat_transfer_number 0 0 ./components/min_temperature.main 1 0 ./components/segment_cost.cost 0 0 ./components/thermal_conductivity.thermal_conductivity 10 0 ./components/thermal_profile.thermal_prof 3 0 ./components/total_cost.total_wall_cost 0 0 ./components/volume.volume 0 0 ./components/weight.weight 0 0 ------------------------------------------------------------------------------------------------------------------------------- Re-using old results After completing a query the Hubit model instance will store the results. If a new query is submitted using the same model and the use_results argument is set to \"current\" in get , Hubit will use the cached results instead of re-calculating them i.e. Hubit will bypass the components that provide the cached results. For example, if the layer costs are queried first followed by a query for the wall total cost, which consumes the layer cost, the layer cost will not be calculated in the second query. An example is shown in examples/wall/run_precompute.py The results can be retrieved from results on the Hubit model instance and can then be saved to disk or otherwise persisted. Manually set results Results can be manually set on the model using the set_results() method on a Hubit model instance. In subsequent queries Hubit will then omit re-calculating the results that have been set, thus bypassing the corresponding providers. The values that are manually set could represent some new measurements that you want to see the effect of when propagated in through the remaining components downstream of the component that is bypassed. The values could also represent persisted results that you want to augment with additional results or analyses without running the entire model again. An example is shown in examples/wall/run_set_results.py . Sweep input parameters Hubit can sweep over different values of the input attributes. The example shows the energy class and cost for different value of the insulation thickness and for different values of the wall materials. examples/wall/run_sweep.py shows an example sweep which results in the table below Wall sweep ------------------------------------------------------------------------------------------------------------------------- Inner Mat. Outer Mat. Seg0 Ins. Thck. [m] Seg1 Ins. Thck. [m] heat_transfer_number energy_class total_cost ------------------------------------------------------------------------------------------------------------------------- brick brick 0.08 0.025 0.80 C 2761 brick brick 0.12 0.065 0.65 B 2804 brick concrete 0.08 0.025 0.84 C 1746 brick concrete 0.12 0.065 0.66 B 1789 concrete brick 0.08 0.025 0.84 C 1619 concrete brick 0.12 0.065 0.66 B 1662 concrete concrete 0.08 0.025 0.89 C 604 concrete concrete 0.12 0.065 0.68 B 647 ------------------------------------------------------------------------------------------------------------------------- The information in the table could conveniently be visualized in a parallel coordinates plot.","title":"Wall"},{"location":"example-wall.html#heat-flow-through-a-wall","text":"In this example we consider a wall that consists of three segments as shown in the illustration below. Face view wall (not to scale) _______________ | segment 1 | 1.5 m |_______________| | | | segment 2 | 2.0 m |_______________| | | | segment 3 | 2.0 m |_______________| 3.0 m Each wall segment consists of different layers as shown in the side view below. Side view of the wall (not to scale) brick air rockwool | | | brick | | | | Inside v v v v Outside ---------------------- | | | | | segment 1 (wall: brick-air-rockwool-brick) temperature = 320 K | | | | | temperature = 273 K ---------------------- || || || || segment 2 (window: glass-air-glass) temperature = 300 K || || temperature = 273 K ---------------------- | | | | | | | | segment 3 (wall: concrete-EPS-concrete) temperature = 300 K | | | | temperature = 273 K ---------------------- ^ ^ ^ | | | concrete | concrete EPS The wall materials, dimensions and other input can be found in wall input file examples/wall/input.yml . Note that the number of wall layers in the two segments differ, which illustrates that Hubit can handle non-rectangular data.","title":"Heat flow through a wall"},{"location":"example-wall.html#model","text":"The wall model is defined in examples/wall/model.yml and define bindings between calculation components that provides certain results. The components are explained in greater detail later. With the model in place Hubit allows users to query the results data structure. For example, to get the \"total_cost\" and \"total_heat_loss\" for the wall we would write from hubit.model import HubitModel hmodel = HubitModel . from_file ( 'model.yml' , name = 'wall' ) query = [ \"total_cost\" , \"heat_transfer_number\" ] response = hmodel . get ( query ) The response to the query is { 'total_cost' : 2365.600380096421 , 'heat_transfer_number' : 0.8888377547279751 } Behind the scenes Hubit constructs and executes the call graph for the query. Only components that provide results that are necessary for constructing the response are spawned. Therefore, the query segment[0].cost would only spawn calculations required to calculate the cost of wall segment 0 while the query total_cost invokes cost calculations for all segments. To understand more about this behavior read the Call graph & multi-processing section below. By using different queries it is straight forward to set up reports for different audiences, each with a customized content, but based on the same model and the same input. Such different reports can service different stakeholders e.g. management, internal design engineers, clients or independent verification agencies.","title":"Model"},{"location":"example-wall.html#components","text":"The source code for the wall model components can be found in the examples/wall/components folder in the repository and are referenced from the model configuration file . A time delay has been added in some of the components to simulate a heavy computational load or a latency in a web service. The time delay illustrates the asynchronous capabilities in Hubit . Some of the calculation components deals with the physics part of the wall model. These components include thermal_conductivity.py . Simple lookup of thermal conductivities based on the material name. thermal_profile.py . A calculation of the temperature for all wall layers in a segment as well as the heat flux in the segment. We assume one-dimensional heat flow, and thus each segment can be treated independently. heat_flow.py . Calculates the heat flow through a segment. heat_transfer_number.py . Calculates the overall heat transfer number and wall energy classification. The wall energy classification ranges from A to D where A indicates the most insulating wall (best) and D indicates the least insulating wall (worst). Many (all) of the components could have been joined in a single component, but here they are kept as separate components to increase modularity, to assure that any query only spawns a minimum of calculations and to maximize the potential speed-up obtained by multi-processing. The wall cost is calculated by the two components below segment_cost.py . Calculates wall segment cost. In the code notice how segments with type 'window' are handled differently compared to other segments types. total_cost.py . Calculates wall total cost. To support the cost calculations two extra engineering components are included volume.py . Calculates the volume of wall layers. weight.py . Calculates the weight of wall layers.","title":"Components"},{"location":"example-wall.html#call-graph-multi-processing","text":"Hubit is event-driven and components are spawned dynamically. The bindings that are used to set up the relations between components are defined in model.yml To illustrate the cascade of events that spawn the necessary calculations let us consider a query for the wall total_cost . In the model file the total cost is provided by total_cost.py . path: ./components/total_cost.py func_name: total_wall_cost provides_results: - name: cost path: total_cost consumes_results: - name: segment_costs path: segments[:@IDX_SEG].cost Further, the model file reveals that the total_cost.py consumes the costs for all segments ( segments[:@IDX_SEG].cost ). The segment costs are, in turn, provided by segment_cost.py as seen from the component definition below, which is also taken from model.yml . path: ./components/segment_cost.py func_name: cost provides_results: - name: cost path: segments[IDX_SEG].cost consumes_input: - name: materials path: segments[IDX_SEG].layers[:@IDX_LAY].material - name: type path: segments[IDX_SEG].type consumes_results: - name: weights path: segments[IDX_SEG].layers[:@IDX_LAY].weight Since the segment costs are not in the results data to begin with Hubit spawns the segment_cost.py calculation. To calculate the segment cost, the material and segment weight must be known for each layer in the segment since these attributes are specified in the consumes_results section. The segment cost component expects the layer materials and weights to be available at segments[IDX_SEG].layers[:@IDX_LAY].material and segments[IDX_SEG].layers[:@IDX_LAY].weight , respectively. The weights are calculated in weight.py and the material (part of the input) is used to look up a price in segment_cost.py . Inspecting model.yml shows that the weight component consumes the layer volume calculated in volume.py . So the original query triggers a cascade of new auxiliary queries that each may spawn new calculations. The calculations are put on hold until the all required data is available. Once this data becomes available the calculation starts and may, after completion, provide data that trigger other pending calculations. Since the cost and heat transfer calculations for each wall segment are independent the event-driven architecture allows Hubit to execute these calculations for each wall segment in parallel if the multi-processing flag is set to True . As we have previously seen, the response to the 'heat_transfer_number' query is { 'heat_transfer_number' : 0.8888377547279751 } All the results that were used to process the query can be accessed using hmodel.results { 'energy_class' : 'C' , 'heat_transfer_number' : 0.8888377547279751 , 'segments' : { 0 : { 'heat_flux' : 13.134093452714046 , 'heat_transfer_number' : 0.2794487968662563 , 'layers' : { 0 : { 'k_therm' : 0.47 , 'outer_temperature' : 317.20551203133743 }, 1 : { 'k_therm' : 0.025 , 'outer_temperature' : 306.6982372691662 }, 2 : { 'k_therm' : 0.034 , 'outer_temperature' : 275.79448796866257 }, 3 : { 'k_therm' : 0.47 , 'outer_temperature' : 273.0 }}}, 1 : { 'heat_flux' : 33.540372670807464 , 'heat_transfer_number' : 1.2422360248447208 , 'layers' : { 0 : { 'k_therm' : 0.8 , 'outer_temperature' : 299.91614906832297 }, 1 : { 'k_therm' : 0.025 , 'outer_temperature' : 273.083850931677 }, 2 : { 'k_therm' : 0.8 , 'outer_temperature' : 272.99999999999994 }}}, 2 : { 'heat_flux' : 26.79699248120301 , 'heat_transfer_number' : 0.9924812030075189 , 'layers' : { 0 : { 'k_therm' : 1.1 , 'outer_temperature' : 296.34586466165416 }, 1 : { 'k_therm' : 0.033 , 'outer_temperature' : 276.0451127819549 }, 2 : { 'k_therm' : 1.1 , 'outer_temperature' : 273.0 }}}}}","title":"Call graph &amp; multi-processing"},{"location":"example-wall.html#example-calculations","text":"The purpose of the examples are summarized below. To run an example using the hubit source code run the example script from the project root e.g. python3 -m examples.wall.run_queries . In some of the examples you can toggle the multi-processing flag to see the performance difference with and without multi-processing. The performance change obtained by activating multi-processing depends on the time spent in the components. You can try to adjust the sleep time in thermal_conductivity.py and thermal_profile.py .","title":"Example calculations"},{"location":"example-wall.html#rending-the-model","text":"To get a graphical overview of a hubit model the model can be rendered if Graphviz is installed . The rendition of the wall model is shown below Hubit can also render a query as illustrated below Notice how the graph representing the query only includes a subset of all the model components. When a query is rendered only the relevant components for that particular query are shown. The example code can be found in examples/wall/render.py .","title":"Rending the model"},{"location":"example-wall.html#queries","text":"This example runs various queries. First the queries are submitted individually, which causes redundant calculations. Second, all the queries are submitted together in which case Hubit will assure that the same result is not calculate multiple times. An example is shown in examples/wall/run_queries.py .","title":"Queries"},{"location":"example-wall.html#indexing-from-the-back-in-the-model","text":"To illustrate the use of negative indices, the model file includes a component that calculates the minimum temperature between the outermost and second outermost wall layers. The temperature at this interface could be of particular engineering interest. To this end the Hubit model component subscribes to segments[IDX_SEG].layers[-2@IDX_LAY].outer_temperature and the minimum temperature is stored in the path service_layer_minimum_temperature . The example in examples/wall/run_min_temperature.py executes hmodel.get([\"service_layer_minimum_temperature\"]) which gives the response {'service_layer_minimum_temperature': 275.79} . The Hubit log reveals that 10 thermal conductivity and 3 thermal profile workers were spawned to produce the response. ------------------------------------------------------------------------------------------------------------------------------ Query finish time Query took (s) Worker name Workers spawned Component cache hits ------------------------------------------------------------------------------------------------------------------------------- 14-Mar-2022 13:06:16 2.5 ./components/heat_flow.heat_flow 0 0 ./components/heat_transfer_number.heat_transfer_number 0 0 ./components/min_temperature.main 1 0 ./components/segment_cost.cost 0 0 ./components/thermal_conductivity.thermal_conductivity 10 0 ./components/thermal_profile.thermal_prof 3 0 ./components/total_cost.total_wall_cost 0 0 ./components/volume.volume 0 0 ./components/weight.weight 0 0 -------------------------------------------------------------------------------------------------------------------------------","title":"Indexing from the back in the model"},{"location":"example-wall.html#re-using-old-results","text":"After completing a query the Hubit model instance will store the results. If a new query is submitted using the same model and the use_results argument is set to \"current\" in get , Hubit will use the cached results instead of re-calculating them i.e. Hubit will bypass the components that provide the cached results. For example, if the layer costs are queried first followed by a query for the wall total cost, which consumes the layer cost, the layer cost will not be calculated in the second query. An example is shown in examples/wall/run_precompute.py The results can be retrieved from results on the Hubit model instance and can then be saved to disk or otherwise persisted.","title":"Re-using old results"},{"location":"example-wall.html#manually-set-results","text":"Results can be manually set on the model using the set_results() method on a Hubit model instance. In subsequent queries Hubit will then omit re-calculating the results that have been set, thus bypassing the corresponding providers. The values that are manually set could represent some new measurements that you want to see the effect of when propagated in through the remaining components downstream of the component that is bypassed. The values could also represent persisted results that you want to augment with additional results or analyses without running the entire model again. An example is shown in examples/wall/run_set_results.py .","title":"Manually set results"},{"location":"example-wall.html#sweep-input-parameters","text":"Hubit can sweep over different values of the input attributes. The example shows the energy class and cost for different value of the insulation thickness and for different values of the wall materials. examples/wall/run_sweep.py shows an example sweep which results in the table below Wall sweep ------------------------------------------------------------------------------------------------------------------------- Inner Mat. Outer Mat. Seg0 Ins. Thck. [m] Seg1 Ins. Thck. [m] heat_transfer_number energy_class total_cost ------------------------------------------------------------------------------------------------------------------------- brick brick 0.08 0.025 0.80 C 2761 brick brick 0.12 0.065 0.65 B 2804 brick concrete 0.08 0.025 0.84 C 1746 brick concrete 0.12 0.065 0.66 B 1789 concrete brick 0.08 0.025 0.84 C 1619 concrete brick 0.12 0.065 0.66 B 1662 concrete concrete 0.08 0.025 0.89 C 604 concrete concrete 0.12 0.065 0.68 B 647 ------------------------------------------------------------------------------------------------------------------------- The information in the table could conveniently be visualized in a parallel coordinates plot.","title":"Sweep input parameters"},{"location":"examples.html","text":"Examples The examples described on the following pages are summarized below. Car encompass four similar car models and is a good first introduction to basic Hubit terminology. The examples illustrate how you can model configuration file to interface with toy calculations for the price of a car that each have different levels of modularity. Further, the example illustrates model-level caching and component-level caching. Wall illustrates heat flow calculations and cost calculations for a wall with three segments. Each wall segment has multiple wall layers that consist of different materials and has different thicknesses. The example demonstrates model rendering ( render.py ), simple queries ( run_queries.py ) with model level caching, reusing previously calculated results run_precompute.py , setting results manually ( run_set_results.py ) and input parameter sweeps ( run_sweep.py ). In run_queries.py a toggle makes it easy to run with or without multi-processing and the the effect on the wall time. Tanks . This example shows how to set up models where one domain (compartment/cell/element) consumes results from a neighboring domain. In the example, a liquid flows from one tank to the next in a cascading fashion. The example encompass two similar tanks models model_1 and model_2 . The former illustrates explicit linking of the tanks, which is useful for an unstructured network of tanks. The latter illustrates a linking pattern which is useful for a structured network of tanks. To run, for example, the car example clone the repository and execute the command below from the project root python -m examples.car.run In the examples all calculations are, for simplicity, carried out directly in the Hubit entrypoint function, but the function could just as well wrap a C library, request data from a web service or use an installed Python package.","title":"Summary"},{"location":"examples.html#examples","text":"The examples described on the following pages are summarized below. Car encompass four similar car models and is a good first introduction to basic Hubit terminology. The examples illustrate how you can model configuration file to interface with toy calculations for the price of a car that each have different levels of modularity. Further, the example illustrates model-level caching and component-level caching. Wall illustrates heat flow calculations and cost calculations for a wall with three segments. Each wall segment has multiple wall layers that consist of different materials and has different thicknesses. The example demonstrates model rendering ( render.py ), simple queries ( run_queries.py ) with model level caching, reusing previously calculated results run_precompute.py , setting results manually ( run_set_results.py ) and input parameter sweeps ( run_sweep.py ). In run_queries.py a toggle makes it easy to run with or without multi-processing and the the effect on the wall time. Tanks . This example shows how to set up models where one domain (compartment/cell/element) consumes results from a neighboring domain. In the example, a liquid flows from one tank to the next in a cascading fashion. The example encompass two similar tanks models model_1 and model_2 . The former illustrates explicit linking of the tanks, which is useful for an unstructured network of tanks. The latter illustrates a linking pattern which is useful for a structured network of tanks. To run, for example, the car example clone the repository and execute the command below from the project root python -m examples.car.run In the examples all calculations are, for simplicity, carried out directly in the Hubit entrypoint function, but the function could just as well wrap a C library, request data from a web service or use an installed Python package.","title":"Examples"},{"location":"hubit-reference.html","text":"Hubit Components described below are available directly from the 'hubit' package. Therefore, the model class can be imported as from hubit import HubitModel . HubitModel results : FlatData property readonly Get model results as FlatData Returns: Type Description FlatData Results for the model instance. clear_cache ( self ) Clear the model cache. Will delete the serialized model cache from the disk if it exists. from_file ( model_file_path , output_path = './' , name = 'NA' ) classmethod Creates a HubitModel from a configuration file. Parameters: Name Type Description Default model_file_path str The location of the model file. required output_path str Path where results should be saved './' name str Model name 'NA' Returns: Type Description HubitModel Hubit model object as defined in the specified model file get ( self , query , use_multi_processing = False , validate = False , use_results = 'none' ) Get the response corresponding to the query On Windows this method should be guarded by if __name__ == '__main__': if use_multi_processing is True Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . required use_multi_processing bool Flag indicating if the respose should be generated using (async) multiprocessing. False validate bool Flag indicating if the query should be validated prior to execution. If True a dry-run of the model will be executed. False use_results str Should previously saved results be used. If use_results is set to \"current\" the results set on the model instance will be used as-is i.e. will not be recalculated. If use_results is set to \"cached\" cached results will be used if they exists. If use_results is set to \"none\" no previously calculated results will be used. 'none' Exceptions: Type Description HubitModelNoInputError If no input is set on the model. HubitModelNoResultsError If use_results = \"current\" but no results are present on the model. HubitError If the specified use_results option is not known. Returns: Type Description Dict[str, Any] The response get_many ( self , query , input_values_for_path , skipfun = None , nproc = None ) Perform a full factorial sampling of the input points specified in input_values_for_path . On Windows calling this method should be guarded by if __name__ == '__main__': Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . required input_values_for_path Dict[str, Any] Dictionary with string keys that each complies with HubitQueryPath . The corresponding values should be an iterable with elements representing discrete values for the attribute at the path. For each factor combination an input data object ( FlatData ) will be created and passed to skipfun . required skipfun Any Callable that takes the flattened input for each factor combination as the only argument. If the skip function returns True the factor combination represented by the input data object is skipped. The default skipfun corresponding to skipfun=None always returns False . None nproc Any Number of processes to use. If None a suitable default is used. None Exceptions: Type Description HubitModelNoInputError If not input is set. Returns: Type Description Tuple Tuple of lists (responses, flat_inputs, flat_results). flat_inputs and flat_results both have elements of type FlatData get_results ( self ) Get model results as FlatData Returns: Type Description FlatData Results for the model instance. has_cached_results ( self ) Check if the model has cached results Returns: Type Description bool The result of the check log ( self ) Get the model log Returns: Type Description HubitLog HubitLog object mpaths_for_qpath_fields_only ( self , qpath ) Find model paths that match the query. The match is evaluated only based on field names render ( self , query = [], file_idstr = '' ) Create graph representing the model or the query and save the image to the model output_path . Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . If not provided (or is empty) the model is rendered. If a non-empty query is provided that query is rendered, which requires the input data be set. [] file_idstr str Identifier appended to the image file name. '' set_component_caching ( self , component_caching ) Set component worker caching on/off. Parameters: Name Type Description Default component_caching bool True corresponds to worker caching being on. required set_input ( self , input_data ) Set the (hierarchical) input on the model. Parameters: Name Type Description Default input_data Dict[str, Any] Input data as a freely formatted, serializable dictionary. required Returns: Type Description HubitModel Hubit model with input set. set_model_caching ( self , caching_mode ) Set the model caching mode. Parameters: Name Type Description Default caching_mode str Valid options are: \"none\", \"incremental\", \"after_execution\". If \"none\" model results are not cached. If \"incremental\" results are saved to disk whenever a component worker finishes its workload. If the caching_mode is set to \"after_execution\" the results are saved to disk when all component workers have finished their workloads. required Results caching is useful when you want to avoid spending time calculating the same results multiple times. A use case for \"incremental\" caching is when a calculation is stopped (computer shutdown, keyboard interrupt, exception raised) before the response has been generated. In such cases the calculation can be restarted from the cached results. The overhead introduced by caching makes it especially useful for CPU bound models. A use case for \"after_execution\" caching is when writing the result data incrementally is a bottleneck. Warning . Cached results are tied to the content of the model configuration file and the model input. Hubit does not check if any of the underlying calculation code has changed. Therefore, using results caching while components are in development is not recommended. Hubit 's behavior in four parameter combinations is summarized below. \"Yes\" in the Write column corresponds to setting the caching level to either \"incremental\" or \"after_execution\" using the set_model_caching method. \"No\" in the Write column corresponds to caching level \"none\". \"Yes\" in the Read column corresponds use_results=\"cached\" in the get method while \"No\" corresponds to use_results=\"none\" . Write Read Behavior Yes Yes Any cached results for the model are loaded. These results will be saved (incrementally or after execution) and may be augmented in the new run depending on the new query Yes No Model results are cached incrementally or after execution. These new results overwrite any existing results cached for the model No Yes Any cached results for the model are loaded. No new results are cached and therefore the cached results will remain the same after execution. No No No results are cached and no results are loaded into the model set_results ( self , results_data ) Set the (hierarchical) results on the model. Parameters: Name Type Description Default results_data Dict[str, Any] Results data as a freely formatted, serializable dictionary. required Returns: Type Description HubitModel Hubit model with input set validate ( self , query = []) Validate a model or query. Will validate as a query if query are provided. Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . [] Exceptions: Type Description HubitModelNoInputError If not input is set. HubitModelValidationError If validation fails. Returns: Type Description bool True if validation was successful. clear_hubit_cache () Clear the cache for all models. Will delete all serialized model cache from the disk.","title":"Hubit"},{"location":"hubit-reference.html#hubit","text":"Components described below are available directly from the 'hubit' package. Therefore, the model class can be imported as from hubit import HubitModel .","title":"Hubit"},{"location":"hubit-reference.html#hubit.model.HubitModel","text":"","title":"HubitModel"},{"location":"hubit-reference.html#hubit.model.HubitModel.results","text":"Get model results as FlatData Returns: Type Description FlatData Results for the model instance.","title":"results"},{"location":"hubit-reference.html#hubit.model.HubitModel.clear_cache","text":"Clear the model cache. Will delete the serialized model cache from the disk if it exists.","title":"clear_cache()"},{"location":"hubit-reference.html#hubit.model.HubitModel.from_file","text":"Creates a HubitModel from a configuration file. Parameters: Name Type Description Default model_file_path str The location of the model file. required output_path str Path where results should be saved './' name str Model name 'NA' Returns: Type Description HubitModel Hubit model object as defined in the specified model file","title":"from_file()"},{"location":"hubit-reference.html#hubit.model.HubitModel.get","text":"Get the response corresponding to the query On Windows this method should be guarded by if __name__ == '__main__': if use_multi_processing is True Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . required use_multi_processing bool Flag indicating if the respose should be generated using (async) multiprocessing. False validate bool Flag indicating if the query should be validated prior to execution. If True a dry-run of the model will be executed. False use_results str Should previously saved results be used. If use_results is set to \"current\" the results set on the model instance will be used as-is i.e. will not be recalculated. If use_results is set to \"cached\" cached results will be used if they exists. If use_results is set to \"none\" no previously calculated results will be used. 'none' Exceptions: Type Description HubitModelNoInputError If no input is set on the model. HubitModelNoResultsError If use_results = \"current\" but no results are present on the model. HubitError If the specified use_results option is not known. Returns: Type Description Dict[str, Any] The response","title":"get()"},{"location":"hubit-reference.html#hubit.model.HubitModel.get_many","text":"Perform a full factorial sampling of the input points specified in input_values_for_path . On Windows calling this method should be guarded by if __name__ == '__main__': Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . required input_values_for_path Dict[str, Any] Dictionary with string keys that each complies with HubitQueryPath . The corresponding values should be an iterable with elements representing discrete values for the attribute at the path. For each factor combination an input data object ( FlatData ) will be created and passed to skipfun . required skipfun Any Callable that takes the flattened input for each factor combination as the only argument. If the skip function returns True the factor combination represented by the input data object is skipped. The default skipfun corresponding to skipfun=None always returns False . None nproc Any Number of processes to use. If None a suitable default is used. None Exceptions: Type Description HubitModelNoInputError If not input is set. Returns: Type Description Tuple Tuple of lists (responses, flat_inputs, flat_results). flat_inputs and flat_results both have elements of type FlatData","title":"get_many()"},{"location":"hubit-reference.html#hubit.model.HubitModel.get_results","text":"Get model results as FlatData Returns: Type Description FlatData Results for the model instance.","title":"get_results()"},{"location":"hubit-reference.html#hubit.model.HubitModel.has_cached_results","text":"Check if the model has cached results Returns: Type Description bool The result of the check","title":"has_cached_results()"},{"location":"hubit-reference.html#hubit.model.HubitModel.log","text":"Get the model log Returns: Type Description HubitLog HubitLog object","title":"log()"},{"location":"hubit-reference.html#hubit.model.HubitModel.mpaths_for_qpath_fields_only","text":"Find model paths that match the query. The match is evaluated only based on field names","title":"mpaths_for_qpath_fields_only()"},{"location":"hubit-reference.html#hubit.model.HubitModel.render","text":"Create graph representing the model or the query and save the image to the model output_path . Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . If not provided (or is empty) the model is rendered. If a non-empty query is provided that query is rendered, which requires the input data be set. [] file_idstr str Identifier appended to the image file name. ''","title":"render()"},{"location":"hubit-reference.html#hubit.model.HubitModel.set_component_caching","text":"Set component worker caching on/off. Parameters: Name Type Description Default component_caching bool True corresponds to worker caching being on. required","title":"set_component_caching()"},{"location":"hubit-reference.html#hubit.model.HubitModel.set_input","text":"Set the (hierarchical) input on the model. Parameters: Name Type Description Default input_data Dict[str, Any] Input data as a freely formatted, serializable dictionary. required Returns: Type Description HubitModel Hubit model with input set.","title":"set_input()"},{"location":"hubit-reference.html#hubit.model.HubitModel.set_model_caching","text":"Set the model caching mode. Parameters: Name Type Description Default caching_mode str Valid options are: \"none\", \"incremental\", \"after_execution\". If \"none\" model results are not cached. If \"incremental\" results are saved to disk whenever a component worker finishes its workload. If the caching_mode is set to \"after_execution\" the results are saved to disk when all component workers have finished their workloads. required Results caching is useful when you want to avoid spending time calculating the same results multiple times. A use case for \"incremental\" caching is when a calculation is stopped (computer shutdown, keyboard interrupt, exception raised) before the response has been generated. In such cases the calculation can be restarted from the cached results. The overhead introduced by caching makes it especially useful for CPU bound models. A use case for \"after_execution\" caching is when writing the result data incrementally is a bottleneck. Warning . Cached results are tied to the content of the model configuration file and the model input. Hubit does not check if any of the underlying calculation code has changed. Therefore, using results caching while components are in development is not recommended. Hubit 's behavior in four parameter combinations is summarized below. \"Yes\" in the Write column corresponds to setting the caching level to either \"incremental\" or \"after_execution\" using the set_model_caching method. \"No\" in the Write column corresponds to caching level \"none\". \"Yes\" in the Read column corresponds use_results=\"cached\" in the get method while \"No\" corresponds to use_results=\"none\" . Write Read Behavior Yes Yes Any cached results for the model are loaded. These results will be saved (incrementally or after execution) and may be augmented in the new run depending on the new query Yes No Model results are cached incrementally or after execution. These new results overwrite any existing results cached for the model No Yes Any cached results for the model are loaded. No new results are cached and therefore the cached results will remain the same after execution. No No No results are cached and no results are loaded into the model","title":"set_model_caching()"},{"location":"hubit-reference.html#hubit.model.HubitModel.set_results","text":"Set the (hierarchical) results on the model. Parameters: Name Type Description Default results_data Dict[str, Any] Results data as a freely formatted, serializable dictionary. required Returns: Type Description HubitModel Hubit model with input set","title":"set_results()"},{"location":"hubit-reference.html#hubit.model.HubitModel.validate","text":"Validate a model or query. Will validate as a query if query are provided. Parameters: Name Type Description Default query List[str] Sequence of strings that complies with Query . [] Exceptions: Type Description HubitModelNoInputError If not input is set. HubitModelValidationError If validation fails. Returns: Type Description bool True if validation was successful.","title":"validate()"},{"location":"hubit-reference.html#hubit.__init__.clear_hubit_cache","text":"Clear the cache for all models. Will delete all serialized model cache from the disk.","title":"clear_hubit_cache()"},{"location":"log-reference.html","text":"Log The model log is useful for debugging a model and for optimizing model performance. HubitLog dataclass Hubit log. For each query, various run data such as the number of workers spawned and the executions time is added to the log as a LogItem as the first element. Often your simply want to print the log for a HubitModel instance e.g. print(hmodel.log()) . get_all ( self , attr ) Get all log item values corresponding to attribute name attr . Examples: To get the elapsed time for all queries on the HubitModel instance hmodel execute hmodel.log().get_all(\"elapsed_time\") . If two queries has been executed on the model, the return value is a list of times e.g. [0.5028373999812175, 0.6225477000162937] where the first element represent the elapsed time for for latest query. Parameters: Name Type Description Default attr str Valid values are attributes names of the LogItem class. required Returns: Type Description List Log item values for attr LogItem dataclass Hubit log item. Keys in all attribute dicts (e.g. worker_counts and cache_counts ) are the same. Parameters: Name Type Description Default elapsed_time float Query execution time required worker_counts Dict[str, int] For each component function name the value is the count of spawned workers. required cache_counts Dict[str, int] For each component function name the value is the number of workers that used the cache. required","title":"Log"},{"location":"log-reference.html#log","text":"The model log is useful for debugging a model and for optimizing model performance.","title":"Log"},{"location":"log-reference.html#hubit.model.HubitLog","text":"Hubit log. For each query, various run data such as the number of workers spawned and the executions time is added to the log as a LogItem as the first element. Often your simply want to print the log for a HubitModel instance e.g. print(hmodel.log()) .","title":"HubitLog"},{"location":"log-reference.html#hubit.model.HubitLog.get_all","text":"Get all log item values corresponding to attribute name attr . Examples: To get the elapsed time for all queries on the HubitModel instance hmodel execute hmodel.log().get_all(\"elapsed_time\") . If two queries has been executed on the model, the return value is a list of times e.g. [0.5028373999812175, 0.6225477000162937] where the first element represent the elapsed time for for latest query. Parameters: Name Type Description Default attr str Valid values are attributes names of the LogItem class. required Returns: Type Description List Log item values for attr","title":"get_all()"},{"location":"log-reference.html#hubit.model.LogItem","text":"Hubit log item. Keys in all attribute dicts (e.g. worker_counts and cache_counts ) are the same. Parameters: Name Type Description Default elapsed_time float Query execution time required worker_counts Dict[str, int] For each component function name the value is the count of spawned workers. required cache_counts Dict[str, int] For each component function name the value is the number of workers that used the cache. required","title":"LogItem"}]}